{
  "title": "软件工程概述",
  "date": "2025-02-01T00:00:00.000Z",
  "tags": [],
  "body": {
    "raw": "\n##  软件工程的三要素\n\n\n* 方法\n* 过程\n* 工具\n\n## **方法（Methodologies）**\n\n* 瀑布模型\n\t* 主要过程顺序进行\n* 敏捷开发\n\t* 迭代开发，快速响应。\n\t* [敏捷软件开发宣言](https://agilemanifesto.org/iso/zhchs/manifesto.html)\n* 原型模型\n\t* 快速开发一个可运行的原型，在此基础上，根据反馈进行改进。\n* 螺旋模型\n\t*  原型 + 瀑布\n\n## 软件开发的主要过程 （**Process**）\n\n过程可以分为以下阶段：\n* 需求分析阶段\n\t* 目标：确认功能，界面，性能等方面 \n\t\t* 收集方式方式：与客户直接沟通，调研，问卷\n\t* 需求分析：可行性、完整性、一致性\n\t\t* 是否可行？是否真的有其价值【伪需求？】！代价是什么【时间,资源可行】？需要做相应的技术调研【能否实现】？\n\t\t* 完整性：\n\t\t\t* 功能完整性： 涵盖的了所有的 user story.\n\t\t\t\t* 什么是user story?  【简短，非正式】\n\t\t\t\t\t* <什么人> 在 <什么地点> 干了<什么事情>, 产生了 <什么效果> 价值。\n\t\t\t\t\t* user story 的 作用：\n\t\t\t\t\t\t* 用共同的语言，促进沟通，聚焦用户需求\n\t\t\t\t\t\t*  利于排优先级与规划\n\t\t\t\t\t\t*  可以作为验收标准\n\t\t\t\t\t* 编写原则\n\t\t\t\t\t\t* 独立性: 每个用户故事需要尽量独立，不依赖其他user story。 方便并行开发。\n\t\t\t\t\t\t* 协商性: user story并不是不变的，敏捷开发中，容忍需求变动。\n\t\t\t\t\t\t* 有价值: 给产品带来收益和竞争性\n\t\t\t\t\t\t* 尽量小,可估计: 工作量和时间。一个user story 关注一个功能做到，可以测试。\n\t\t\t* 数据完整性？分析数据流，数据的输入，处理输出都有明确的需求\n\t\t\t\t* 数据字典：数据库表结构，软件的开发中的 `DTO`,`Entity`\n\t\t\t* 非功能完整性？\n\t\t\t\t* **安全，性能，兼容性**？\n\t\t\t\t* 行业标准？\n\t\t* 一致性：\n\t\t\t* 不同功能之间是否冲突？\n\t\t\t* 需求与约束条件存在冲突？\n\t* 输出：需求规格说明书\n\t\t* 描述了软件系统的功能、性能、界面、数据等方面的需求。它是开发团队和用户之间沟通的桥梁，也是后续设计、编码、测试和验收的依据。\n\t\t* 设计稿 + user story\n* 设计\n\t* 目标：总体架构，模块划分，接口设计 + 详细设计\n\t* 主要阶段\n\t\t* 概要设计：模块划分、模块之间的关系、数据结构，接口设计 ，数据流。\n\t\t* 详细设计：算法设计、数据结构设计、接口设计\n\t\t* 设计文档：系统架构图，模块设计说明书\n\t* 重要性：是开发的 “蓝图” 阶段。\n\t\t* 怎么理解？\n\t\t\t* 扩展性\n\t\t\t\t* 将功能分为多个独立【低耦合】模块，模块之间通过【接口】进行交互【数据】。\n\t\t\t\t* 系统的架构: 确定系统的**整体结构，包括系统的分层、模块划分和组件**分布\n\t\t\t\t\t* 常见的架构：分层架构，微服务架构，B/S , C/S\n\t\t\t* 维护性\n\t\t\t\t* 设计编码范式与设计模式\n\t\t\t\t* 良好的设计文档\n\t\t\t* 软件性能\n\t\t\t\t* 算法与数据结构影响\n\t\t\t\t* 服务器架构与缓存设计影响网络传输速度\n\t\t\t\t* 好的模块化设计，减少不必要的数据传输影响\n* 编码\n\t* 目的：将设计转为可以运行的代码\n\t* 流程：Code --> Unit test --> Code Review\n\t\t* 编码阶段注意：\n\t\t\t* 编码规范\n\t\t\t\t* 命名规则\n\t\t\t\t* 格式缩进\n\t\t\t* 添加注释\n\t\t\t* 代码结构\n\t\t\t\t* 面向对象的原则\n\t\t\t* 编写必要的开发文档\n\t\t\t* 持续学习，优化现有代码\n* 测试\n\t* 目的：对软件进行全面的验证，符合需求规格说明书\n\t* 流程：\n\t\t* 测试计划\n\t\t* 测试用例编写\n\t\t* 测试执行\n\t\t* 测试管理\n\t\t* 回归测试\n\t* 重要性：测试阶段是软件开发过程中的质量保障阶段，通过测试可以发现软件中的缺陷和问题，确保软件的质量。\n* 部署\n\t* 安装到目标环境\n\t* 流程：制定部署计划，步骤，以及资源\n\t* 重要性：部署可以将软件交付给用户使用\n* 维护\n\t* 定义：确保软件能够持续满足用户的需求，并适应环境的变化。\n\t* 维护阶段是软件开发过程中的持续改进阶段，通过维护可以延长软件的生命周期，提高软件的用户体验。\n\n\n```mermaid\ngraph LR\n    A[开始] --> B[需求分析]\n    B --> C{需求是否明确？}\n    C -->|是| D[设计阶段]\n    C -->|否| B\n    D --> E{设计是否符合需求？}\n    E -->|是| F[编码阶段]\n    E -->|否| B\n    F --> G[单元测试]\n    G --> H{代码是否通过测试？}\n    H -->|是| I[测试阶段]\n    H -->|否| F\n    I --> J[部署阶段]\n    J --> K[维护阶段]\n    K --> L[结束]\n```\n\n\n## 软件开发中工具（**Tools**）\n\n常见工具：\n\n* 项目管理 (jira, 看板)\n* 开发工具 \n* 版本控制 (git)\n* 测试工具 (Junit, Selenium, 性能测试工具)\n* 代码分析工具 （SonarQube）\n* 部署工具 （Docker,Kubernetes）\n### 文档工具\n\n#### 图表(**UML**)\n```\n用例图：通常在需求分析阶段使用，帮助识别系统的主要功能和参与者，为设计阶段提供基础。\n类图：在设计阶段使用，帮助设计系统的静态结构，明确类的职责和关系。\n实体关系图：在设计阶段使用，帮助设计系统的数据模型，生成数据库表结构。\n组件图：在设计阶段使用，帮助设计系统的物理结构，明确组件的职责和依赖关系。\n部署图：在设计阶段使用，帮助设计系统的物理部署结构，确保系统的正确部署。\n活动图：在需求分析和设计阶段使用，帮助理解业务流程，设计系统的业务流程。\n序列图：在设计阶段使用，帮助设计系统的动态行为，明确对象之间的交互顺序。\n状态图：在设计阶段使用，帮助设计系统的状态管理，明确对象在不同状态下的行为。\n数据流图：在需求分析和设计阶段使用，帮助理解系统的数据处理逻辑，设计数据处理流程。\n```\n\n软件工程中的图表\n├── 用例图（Use Case Diagram）\n│   ├── 定义：描述系统功能和用户交互\n│   ├── 作用\n│   │   ├── 需求分析：识别功能和参与者\n│   │   ├── 沟通工具：开发团队与用户沟通\n│   │   └── 设计基础：确定模块和接口\n│   └── 示例：在线购物系统功能\n└── 数据流图（Data Flow Diagram, DFD）\n│   ├── 定义：描述系统数据流动和处理过程\n│   ├── 作用\n│   │   ├── 需求分析：理解数据处理逻辑\n│   │   ├── 设计阶段：设计数据处理流程\n│   │   └── 文档化：提供数据处理文档\n│   └── 示例：图书馆管理系统借阅流程\n├── 类图（Class Diagram）\n│   ├── 定义：描述系统静态结构，类、接口、属性和方法\n│   ├── 作用\n│   │   ├── 设计阶段：设计类结构和关系\n│   │   ├── 代码生成：自动生成部分代码\n│   │   └── 文档化：提供类结构文档\n│   └── 示例：学生管理系统类关系\n├──，（Entity-Relationship Diagram, ERD）\n│   ├── 定义：描述系统数据模型，实体、属性和关系\n│   ├── 作用\n│   │   ├── 设计阶段：设计数据模型\n│   │   ├── 数据库设计：生成数据库表结构\n│   │   └── 文档化：提供数据模型文档\n│   └── 示例：学生管理系统数据模型\n├── 组件图（Component Diagram）\n│   ├── 定义：描述系统物理结构，组件、接口和依赖\n│   ├── 作用\n│   │   ├── 设计阶段：设计物理结构\n│   │   ├── 部署阶段：指导组件部署\n│   │   └── 文档化：提供物理结构文档\n│   └── 示例：分布式系统组件关系\n├── 部署图（Deployment Diagram）\n│   ├── 定义：描述系统物理部署结构，节点、组件和通信路径\n│   ├── 作用\n│   │   ├── 设计阶段：设计物理部署结构\n│   │   ├── 部署阶段：指导系统部署\n│   │   └── 文档化：提供物理部署文档\n│   └── 示例：云计算环境部署\n├── 活动图（Activity Diagram）\n│   ├── 定义：描述系统业务流程或工作流程\n│   ├── 作用\n│   │   ├── 需求分析：理解业务流程\n│   │   ├── 设计阶段：设计业务流程\n│   │   └── 文档化：提供业务流程文档\n│   └── 示例：请假审批系统流程\n├── 序列图（Sequence Diagram）\n│   ├── 定义：描述对象交互顺序，消息传递\n│   ├── 作用\n│   │   ├── 设计阶段：设计系统动态行为\n│   │   ├── 测试阶段：编写测试用例\n│   │   └── 文档化：提供动态行为文档\n│   └── 示例：订单处理系统交互过程\n├── 状态图（State Diagram）\n   ├── 定义：描述对象状态变化和触发事件\n   ├── 作用\n   │   ├── 设计阶段：设计状态管理\n   │   ├── 测试阶段：编写测试用例\n   │   └── 文档化：提供状态管理文档\n   └── 示例：在线支付系统状态变化\n\n\n\n",
    "html": "<h2>软件工程的三要素</h2>\n<ul>\n<li>方法</li>\n<li>过程</li>\n<li>工具</li>\n</ul>\n<h2><strong>方法（Methodologies）</strong></h2>\n<ul>\n<li>瀑布模型\n<ul>\n<li>主要过程顺序进行</li>\n</ul>\n</li>\n<li>敏捷开发\n<ul>\n<li>迭代开发，快速响应。</li>\n<li><a href=\"https://agilemanifesto.org/iso/zhchs/manifesto.html\">敏捷软件开发宣言</a></li>\n</ul>\n</li>\n<li>原型模型\n<ul>\n<li>快速开发一个可运行的原型，在此基础上，根据反馈进行改进。</li>\n</ul>\n</li>\n<li>螺旋模型\n<ul>\n<li>原型 + 瀑布</li>\n</ul>\n</li>\n</ul>\n<h2>软件开发的主要过程 （<strong>Process</strong>）</h2>\n<p>过程可以分为以下阶段：</p>\n<ul>\n<li>需求分析阶段\n<ul>\n<li>目标：确认功能，界面，性能等方面\n<ul>\n<li>收集方式方式：与客户直接沟通，调研，问卷</li>\n</ul>\n</li>\n<li>需求分析：可行性、完整性、一致性\n<ul>\n<li>是否可行？是否真的有其价值【伪需求？】！代价是什么【时间,资源可行】？需要做相应的技术调研【能否实现】？</li>\n<li>完整性：\n<ul>\n<li>功能完整性： 涵盖的了所有的 user story.\n<ul>\n<li>什么是user story?  【简短，非正式】\n<ul>\n<li>&#x3C;什么人> 在 &#x3C;什么地点> 干了&#x3C;什么事情>, 产生了 &#x3C;什么效果> 价值。</li>\n<li>user story 的 作用：\n<ul>\n<li>用共同的语言，促进沟通，聚焦用户需求</li>\n<li>利于排优先级与规划</li>\n<li>可以作为验收标准</li>\n</ul>\n</li>\n<li>编写原则\n<ul>\n<li>独立性: 每个用户故事需要尽量独立，不依赖其他user story。 方便并行开发。</li>\n<li>协商性: user story并不是不变的，敏捷开发中，容忍需求变动。</li>\n<li>有价值: 给产品带来收益和竞争性</li>\n<li>尽量小,可估计: 工作量和时间。一个user story 关注一个功能做到，可以测试。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据完整性？分析数据流，数据的输入，处理输出都有明确的需求\n<ul>\n<li>数据字典：数据库表结构，软件的开发中的 <code>DTO</code>,<code>Entity</code></li>\n</ul>\n</li>\n<li>非功能完整性？\n<ul>\n<li><strong>安全，性能，兼容性</strong>？</li>\n<li>行业标准？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>一致性：\n<ul>\n<li>不同功能之间是否冲突？</li>\n<li>需求与约束条件存在冲突？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>输出：需求规格说明书\n<ul>\n<li>描述了软件系统的功能、性能、界面、数据等方面的需求。它是开发团队和用户之间沟通的桥梁，也是后续设计、编码、测试和验收的依据。</li>\n<li>设计稿 + user story</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>设计\n<ul>\n<li>目标：总体架构，模块划分，接口设计 + 详细设计</li>\n<li>主要阶段\n<ul>\n<li>概要设计：模块划分、模块之间的关系、数据结构，接口设计 ，数据流。</li>\n<li>详细设计：算法设计、数据结构设计、接口设计</li>\n<li>设计文档：系统架构图，模块设计说明书</li>\n</ul>\n</li>\n<li>重要性：是开发的 “蓝图” 阶段。\n<ul>\n<li>怎么理解？\n<ul>\n<li>扩展性\n<ul>\n<li>将功能分为多个独立【低耦合】模块，模块之间通过【接口】进行交互【数据】。</li>\n<li>系统的架构: 确定系统的<strong>整体结构，包括系统的分层、模块划分和组件</strong>分布\n<ul>\n<li>常见的架构：分层架构，微服务架构，B/S , C/S</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>维护性\n<ul>\n<li>设计编码范式与设计模式</li>\n<li>良好的设计文档</li>\n</ul>\n</li>\n<li>软件性能\n<ul>\n<li>算法与数据结构影响</li>\n<li>服务器架构与缓存设计影响网络传输速度</li>\n<li>好的模块化设计，减少不必要的数据传输影响</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>编码\n<ul>\n<li>目的：将设计转为可以运行的代码</li>\n<li>流程：Code --> Unit test --> Code Review\n<ul>\n<li>编码阶段注意：\n<ul>\n<li>编码规范\n<ul>\n<li>命名规则</li>\n<li>格式缩进</li>\n</ul>\n</li>\n<li>添加注释</li>\n<li>代码结构\n<ul>\n<li>面向对象的原则</li>\n</ul>\n</li>\n<li>编写必要的开发文档</li>\n<li>持续学习，优化现有代码</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>测试\n<ul>\n<li>目的：对软件进行全面的验证，符合需求规格说明书</li>\n<li>流程：\n<ul>\n<li>测试计划</li>\n<li>测试用例编写</li>\n<li>测试执行</li>\n<li>测试管理</li>\n<li>回归测试</li>\n</ul>\n</li>\n<li>重要性：测试阶段是软件开发过程中的质量保障阶段，通过测试可以发现软件中的缺陷和问题，确保软件的质量。</li>\n</ul>\n</li>\n<li>部署\n<ul>\n<li>安装到目标环境</li>\n<li>流程：制定部署计划，步骤，以及资源</li>\n<li>重要性：部署可以将软件交付给用户使用</li>\n</ul>\n</li>\n<li>维护\n<ul>\n<li>定义：确保软件能够持续满足用户的需求，并适应环境的变化。</li>\n<li>维护阶段是软件开发过程中的持续改进阶段，通过维护可以延长软件的生命周期，提高软件的用户体验。</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-mermaid\">graph LR\n    A[开始] --> B[需求分析]\n    B --> C{需求是否明确？}\n    C -->|是| D[设计阶段]\n    C -->|否| B\n    D --> E{设计是否符合需求？}\n    E -->|是| F[编码阶段]\n    E -->|否| B\n    F --> G[单元测试]\n    G --> H{代码是否通过测试？}\n    H -->|是| I[测试阶段]\n    H -->|否| F\n    I --> J[部署阶段]\n    J --> K[维护阶段]\n    K --> L[结束]\n</code></pre>\n<h2>软件开发中工具（<strong>Tools</strong>）</h2>\n<p>常见工具：</p>\n<ul>\n<li>项目管理 (jira, 看板)</li>\n<li>开发工具</li>\n<li>版本控制 (git)</li>\n<li>测试工具 (Junit, Selenium, 性能测试工具)</li>\n<li>代码分析工具 （SonarQube）</li>\n<li>部署工具 （Docker,Kubernetes）</li>\n</ul>\n<h3>文档工具</h3>\n<h4>图表(<strong>UML</strong>)</h4>\n<pre><code>用例图：通常在需求分析阶段使用，帮助识别系统的主要功能和参与者，为设计阶段提供基础。\n类图：在设计阶段使用，帮助设计系统的静态结构，明确类的职责和关系。\n实体关系图：在设计阶段使用，帮助设计系统的数据模型，生成数据库表结构。\n组件图：在设计阶段使用，帮助设计系统的物理结构，明确组件的职责和依赖关系。\n部署图：在设计阶段使用，帮助设计系统的物理部署结构，确保系统的正确部署。\n活动图：在需求分析和设计阶段使用，帮助理解业务流程，设计系统的业务流程。\n序列图：在设计阶段使用，帮助设计系统的动态行为，明确对象之间的交互顺序。\n状态图：在设计阶段使用，帮助设计系统的状态管理，明确对象在不同状态下的行为。\n数据流图：在需求分析和设计阶段使用，帮助理解系统的数据处理逻辑，设计数据处理流程。\n</code></pre>\n<p>软件工程中的图表\n├── 用例图（Use Case Diagram）\n│   ├── 定义：描述系统功能和用户交互\n│   ├── 作用\n│   │   ├── 需求分析：识别功能和参与者\n│   │   ├── 沟通工具：开发团队与用户沟通\n│   │   └── 设计基础：确定模块和接口\n│   └── 示例：在线购物系统功能\n└── 数据流图（Data Flow Diagram, DFD）\n│   ├── 定义：描述系统数据流动和处理过程\n│   ├── 作用\n│   │   ├── 需求分析：理解数据处理逻辑\n│   │   ├── 设计阶段：设计数据处理流程\n│   │   └── 文档化：提供数据处理文档\n│   └── 示例：图书馆管理系统借阅流程\n├── 类图（Class Diagram）\n│   ├── 定义：描述系统静态结构，类、接口、属性和方法\n│   ├── 作用\n│   │   ├── 设计阶段：设计类结构和关系\n│   │   ├── 代码生成：自动生成部分代码\n│   │   └── 文档化：提供类结构文档\n│   └── 示例：学生管理系统类关系\n├──，（Entity-Relationship Diagram, ERD）\n│   ├── 定义：描述系统数据模型，实体、属性和关系\n│   ├── 作用\n│   │   ├── 设计阶段：设计数据模型\n│   │   ├── 数据库设计：生成数据库表结构\n│   │   └── 文档化：提供数据模型文档\n│   └── 示例：学生管理系统数据模型\n├── 组件图（Component Diagram）\n│   ├── 定义：描述系统物理结构，组件、接口和依赖\n│   ├── 作用\n│   │   ├── 设计阶段：设计物理结构\n│   │   ├── 部署阶段：指导组件部署\n│   │   └── 文档化：提供物理结构文档\n│   └── 示例：分布式系统组件关系\n├── 部署图（Deployment Diagram）\n│   ├── 定义：描述系统物理部署结构，节点、组件和通信路径\n│   ├── 作用\n│   │   ├── 设计阶段：设计物理部署结构\n│   │   ├── 部署阶段：指导系统部署\n│   │   └── 文档化：提供物理部署文档\n│   └── 示例：云计算环境部署\n├── 活动图（Activity Diagram）\n│   ├── 定义：描述系统业务流程或工作流程\n│   ├── 作用\n│   │   ├── 需求分析：理解业务流程\n│   │   ├── 设计阶段：设计业务流程\n│   │   └── 文档化：提供业务流程文档\n│   └── 示例：请假审批系统流程\n├── 序列图（Sequence Diagram）\n│   ├── 定义：描述对象交互顺序，消息传递\n│   ├── 作用\n│   │   ├── 设计阶段：设计系统动态行为\n│   │   ├── 测试阶段：编写测试用例\n│   │   └── 文档化：提供动态行为文档\n│   └── 示例：订单处理系统交互过程\n├── 状态图（State Diagram）\n├── 定义：描述对象状态变化和触发事件\n├── 作用\n│   ├── 设计阶段：设计状态管理\n│   ├── 测试阶段：编写测试用例\n│   └── 文档化：提供状态管理文档\n└── 示例：在线支付系统状态变化</p>"
  },
  "_id": "软件工程概述.md",
  "_raw": {
    "sourceFilePath": "软件工程概述.md",
    "sourceFileName": "软件工程概述.md",
    "sourceFileDir": ".",
    "contentType": "markdown",
    "flattenedPath": "软件工程概述"
  },
  "type": "Post",
  "slug": "软件工程概述",
  "path": "软件工程概述",
  "filePath": "软件工程概述.md",
  "toc": [
    {
      "value": "软件工程的三要素",
      "url": "#软件工程的三要素",
      "depth": 2
    },
    {
      "value": "方法（Methodologies）",
      "url": "#方法methodologies",
      "depth": 2
    },
    {
      "value": "软件开发的主要过程 （Process）",
      "url": "#软件开发的主要过程-process",
      "depth": 2
    },
    {
      "value": "软件开发中工具（Tools）",
      "url": "#软件开发中工具tools",
      "depth": 2
    },
    {
      "value": "文档工具",
      "url": "#文档工具",
      "depth": 3
    },
    {
      "value": "图表(UML)",
      "url": "#图表uml",
      "depth": 4
    }
  ],
  "structuredData": {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "软件工程概述",
    "datePublished": "2025-02-01T00:00:00.000Z",
    "dateModified": "2025-02-01T00:00:00.000Z",
    "image": "/static/images/twitter-card.png",
    "url": "https://tailwind-nextjs-starter-blog.vercel.app/软件工程概述"
  }
}
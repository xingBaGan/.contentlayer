[
  {
    "title": "什么是ADB? 及其常用命令",
    "date": "2025-02-19T00:00:00.000Z",
    "tags": [],
    "body": {
      "raw": "\n\nadb （android debugger bridge）\nADB，全称为Android Debug Bridge，即安卓调试桥，是一种功能多样的命令行工具，它允许用户与Android设备（包括模拟器）进行通信。ADB主要用于开发者在开发和调试Android应用程序时，通过电脑对设备进行操作，如安装和卸载应用、复制文件、运行shell命令、查看设备日志等。\n\nADB是Android SDK（Software Development Kit）的一部分，它包含三个主要组件：\n\n1. 客户端（Client）：在开发机器上运行，用于发送命令。用户可以通过命令行终端使用ADB命令。\n2. 守护程序（adbd）：在Android设备上作为后台进程运行，处理来自ADB服务器的命令请求。\n3. 服务器（Server）：在开发机器上运行，管理客户端与守护程序之间的通信。\n    \n\n使用ADB时，用户可以通过USB数据线或网络（如Wi-Fi）连接设备。一旦连接成功，就可以执行各种ADB命令来管理设备或进行调试。例如，可以使用`adb devices`列出连接的设备，`adb install <apk>`安装应用，`adb shell`进入设备的shell环境等。ADB是Android开发和测试中不可或缺的工具。\n\n通过数据线链接\n`adb devices`\n\n看到连接的设备\n\n重启adb服务器\n`adb tcpip 5555` \n\n\n进入要调试的控制台\n\n```shell\nadb shell\n\nsu\n\nifconfig \n```\n\n连接远程的设备\n`adb connect ip:5555\n\nadb connect 192.168.0.100:5555\n查看正在运行 [查看手机上 app 的包名 几种方式_查看app包名_百年渔翁_肯肯的博客-CSDN博客](https://blog.csdn.net/qq_30007885/article/details/119418593#:~:text=%E6%9F%A5%E7%9C%8B%E6%89%8B%E6%9C%BA%E4%B8%8A%20app%20%E7%9A%84%E5%8C%85%E5%90%8D%20%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%201%20adb,shell%202%20%E6%9F%A5%E8%AF%A2%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%20app%20%E7%9A%84%E5%8C%85%E5%90%8D%203%20%E6%9F%A5%E7%9C%8B%E5%90%AF%E5%8A%A8activity)\n\n```\nC:\\Users\\10630>adb shell dumpsys window | findstr mCurrentFocus\n  mCurrentFocus=Window{c3cd2c3 u0 eu.pokemmo.client/eu.pokemmo.client.AndroidLauncher\n```\n\n eu.pokemmo.client\n\n``",
      "html": "<p>adb （android debugger bridge）\nADB，全称为Android Debug Bridge，即安卓调试桥，是一种功能多样的命令行工具，它允许用户与Android设备（包括模拟器）进行通信。ADB主要用于开发者在开发和调试Android应用程序时，通过电脑对设备进行操作，如安装和卸载应用、复制文件、运行shell命令、查看设备日志等。</p>\n<p>ADB是Android SDK（Software Development Kit）的一部分，它包含三个主要组件：</p>\n<ol>\n<li>客户端（Client）：在开发机器上运行，用于发送命令。用户可以通过命令行终端使用ADB命令。</li>\n<li>守护程序（adbd）：在Android设备上作为后台进程运行，处理来自ADB服务器的命令请求。</li>\n<li>服务器（Server）：在开发机器上运行，管理客户端与守护程序之间的通信。</li>\n</ol>\n<p>使用ADB时，用户可以通过USB数据线或网络（如Wi-Fi）连接设备。一旦连接成功，就可以执行各种ADB命令来管理设备或进行调试。例如，可以使用<code>adb devices</code>列出连接的设备，<code>adb install &#x3C;apk></code>安装应用，<code>adb shell</code>进入设备的shell环境等。ADB是Android开发和测试中不可或缺的工具。</p>\n<p>通过数据线链接\n<code>adb devices</code></p>\n<p>看到连接的设备</p>\n<p>重启adb服务器\n<code>adb tcpip 5555</code></p>\n<p>进入要调试的控制台</p>\n<pre><code class=\"language-shell\">adb shell\n\nsu\n\nifconfig \n</code></pre>\n<p>连接远程的设备\n`adb connect ip:5555</p>\n<p>adb connect 192.168.0.100:5555\n查看正在运行 <a href=\"https://blog.csdn.net/qq_30007885/article/details/119418593#:~:text=%E6%9F%A5%E7%9C%8B%E6%89%8B%E6%9C%BA%E4%B8%8A%20app%20%E7%9A%84%E5%8C%85%E5%90%8D%20%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%201%20adb,shell%202%20%E6%9F%A5%E8%AF%A2%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%20app%20%E7%9A%84%E5%8C%85%E5%90%8D%203%20%E6%9F%A5%E7%9C%8B%E5%90%AF%E5%8A%A8activity\">查看手机上 app 的包名 几种方式_查看app包名_百年渔翁_肯肯的博客-CSDN博客</a></p>\n<pre><code>C:\\Users\\10630>adb shell dumpsys window | findstr mCurrentFocus\n  mCurrentFocus=Window{c3cd2c3 u0 eu.pokemmo.client/eu.pokemmo.client.AndroidLauncher\n</code></pre>\n<p>eu.pokemmo.client</p>\n<p>``</p>"
    },
    "_id": "adb 常用命令.md",
    "_raw": {
      "sourceFilePath": "adb 常用命令.md",
      "sourceFileName": "adb 常用命令.md",
      "sourceFileDir": ".",
      "contentType": "markdown",
      "flattenedPath": "adb 常用命令"
    },
    "type": "Post",
    "slug": "adb 常用命令",
    "path": "adb 常用命令",
    "filePath": "adb 常用命令.md",
    "toc": [],
    "structuredData": {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "headline": "什么是ADB? 及其常用命令",
      "datePublished": "2025-02-19T00:00:00.000Z",
      "dateModified": "2025-02-19T00:00:00.000Z",
      "image": "/static/images/twitter-card.png",
      "url": "https://tailwind-nextjs-starter-blog.vercel.app/adb 常用命令"
    }
  },
  {
    "title": "什么是ADB? 及其常用命令",
    "date": "2025-02-19T00:00:00.000Z",
    "tags": [],
    "body": {
      "raw": "\n\nadb （android debugger bridge）\nADB，全称为Android Debug Bridge，即安卓调试桥，是一种功能多样的命令行工具，它允许用户与Android设备（包括模拟器）进行通信。ADB主要用于开发者在开发和调试Android应用程序时，通过电脑对设备进行操作，如安装和卸载应用、复制文件、运行shell命令、查看设备日志等。\n\nADB是Android SDK（Software Development Kit）的一部分，它包含三个主要组件：\n\n1. 客户端（Client）：在开发机器上运行，用于发送命令。用户可以通过命令行终端使用ADB命令。\n2. 守护程序（adbd）：在Android设备上作为后台进程运行，处理来自ADB服务器的命令请求。\n3. 服务器（Server）：在开发机器上运行，管理客户端与守护程序之间的通信。\n    \n\n使用ADB时，用户可以通过USB数据线或网络（如Wi-Fi）连接设备。一旦连接成功，就可以执行各种ADB命令来管理设备或进行调试。例如，可以使用`adb devices`列出连接的设备，`adb install <apk>`安装应用，`adb shell`进入设备的shell环境等。ADB是Android开发和测试中不可或缺的工具。\n\n通过数据线链接\n`adb devices`\n\n看到连接的设备\n\n重启adb服务器\n`adb tcpip 5555` \n\n\n进入要调试的控制台\n\n```shell\nadb shell\n\nsu\n\nifconfig \n```\n\n连接远程的设备\n`adb connect ip:5555\n\nadb connect 192.168.0.100:5555\n查看正在运行 [查看手机上 app 的包名 几种方式_查看app包名_百年渔翁_肯肯的博客-CSDN博客](https://blog.csdn.net/qq_30007885/article/details/119418593#:~:text=%E6%9F%A5%E7%9C%8B%E6%89%8B%E6%9C%BA%E4%B8%8A%20app%20%E7%9A%84%E5%8C%85%E5%90%8D%20%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%201%20adb,shell%202%20%E6%9F%A5%E8%AF%A2%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%20app%20%E7%9A%84%E5%8C%85%E5%90%8D%203%20%E6%9F%A5%E7%9C%8B%E5%90%AF%E5%8A%A8activity)\n\n```\nC:\\Users\\10630>adb shell dumpsys window | findstr mCurrentFocus\n  mCurrentFocus=Window{c3cd2c3 u0 eu.pokemmo.client/eu.pokemmo.client.AndroidLauncher\n```\n\n eu.pokemmo.client\n\n``",
      "html": "<p>adb （android debugger bridge）\nADB，全称为Android Debug Bridge，即安卓调试桥，是一种功能多样的命令行工具，它允许用户与Android设备（包括模拟器）进行通信。ADB主要用于开发者在开发和调试Android应用程序时，通过电脑对设备进行操作，如安装和卸载应用、复制文件、运行shell命令、查看设备日志等。</p>\n<p>ADB是Android SDK（Software Development Kit）的一部分，它包含三个主要组件：</p>\n<ol>\n<li>客户端（Client）：在开发机器上运行，用于发送命令。用户可以通过命令行终端使用ADB命令。</li>\n<li>守护程序（adbd）：在Android设备上作为后台进程运行，处理来自ADB服务器的命令请求。</li>\n<li>服务器（Server）：在开发机器上运行，管理客户端与守护程序之间的通信。</li>\n</ol>\n<p>使用ADB时，用户可以通过USB数据线或网络（如Wi-Fi）连接设备。一旦连接成功，就可以执行各种ADB命令来管理设备或进行调试。例如，可以使用<code>adb devices</code>列出连接的设备，<code>adb install &#x3C;apk></code>安装应用，<code>adb shell</code>进入设备的shell环境等。ADB是Android开发和测试中不可或缺的工具。</p>\n<p>通过数据线链接\n<code>adb devices</code></p>\n<p>看到连接的设备</p>\n<p>重启adb服务器\n<code>adb tcpip 5555</code></p>\n<p>进入要调试的控制台</p>\n<pre><code class=\"language-shell\">adb shell\n\nsu\n\nifconfig \n</code></pre>\n<p>连接远程的设备\n`adb connect ip:5555</p>\n<p>adb connect 192.168.0.100:5555\n查看正在运行 <a href=\"https://blog.csdn.net/qq_30007885/article/details/119418593#:~:text=%E6%9F%A5%E7%9C%8B%E6%89%8B%E6%9C%BA%E4%B8%8A%20app%20%E7%9A%84%E5%8C%85%E5%90%8D%20%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%201%20adb,shell%202%20%E6%9F%A5%E8%AF%A2%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%20app%20%E7%9A%84%E5%8C%85%E5%90%8D%203%20%E6%9F%A5%E7%9C%8B%E5%90%AF%E5%8A%A8activity\">查看手机上 app 的包名 几种方式_查看app包名_百年渔翁_肯肯的博客-CSDN博客</a></p>\n<pre><code>C:\\Users\\10630>adb shell dumpsys window | findstr mCurrentFocus\n  mCurrentFocus=Window{c3cd2c3 u0 eu.pokemmo.client/eu.pokemmo.client.AndroidLauncher\n</code></pre>\n<p>eu.pokemmo.client</p>\n<p>``</p>"
    },
    "_id": "adb 常用命令1740386935890.md",
    "_raw": {
      "sourceFilePath": "adb 常用命令1740386935890.md",
      "sourceFileName": "adb 常用命令1740386935890.md",
      "sourceFileDir": ".",
      "contentType": "markdown",
      "flattenedPath": "adb 常用命令1740386935890"
    },
    "type": "Post",
    "slug": "adb 常用命令1740386935890",
    "path": "adb 常用命令1740386935890",
    "filePath": "adb 常用命令1740386935890.md",
    "toc": [],
    "structuredData": {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "headline": "什么是ADB? 及其常用命令",
      "datePublished": "2025-02-19T00:00:00.000Z",
      "dateModified": "2025-02-19T00:00:00.000Z",
      "image": "/static/images/twitter-card.png",
      "url": "https://tailwind-nextjs-starter-blog.vercel.app/adb 常用命令1740386935890"
    }
  },
  {
    "title": "什么是ADB? 及其常用命令",
    "date": "2025-02-19T00:00:00.000Z",
    "tags": [],
    "body": {
      "raw": "\n\nadb （android debugger bridge）\nADB，全称为Android Debug Bridge，即安卓调试桥，是一种功能多样的命令行工具，它允许用户与Android设备（包括模拟器）进行通信。ADB主要用于开发者在开发和调试Android应用程序时，通过电脑对设备进行操作，如安装和卸载应用、复制文件、运行shell命令、查看设备日志等。\n\nADB是Android SDK（Software Development Kit）的一部分，它包含三个主要组件：\n\n1. 客户端（Client）：在开发机器上运行，用于发送命令。用户可以通过命令行终端使用ADB命令。\n2. 守护程序（adbd）：在Android设备上作为后台进程运行，处理来自ADB服务器的命令请求。\n3. 服务器（Server）：在开发机器上运行，管理客户端与守护程序之间的通信。\n    \n\n使用ADB时，用户可以通过USB数据线或网络（如Wi-Fi）连接设备。一旦连接成功，就可以执行各种ADB命令来管理设备或进行调试。例如，可以使用`adb devices`列出连接的设备，`adb install <apk>`安装应用，`adb shell`进入设备的shell环境等。ADB是Android开发和测试中不可或缺的工具。\n\n通过数据线链接\n`adb devices`\n\n看到连接的设备\n\n重启adb服务器\n`adb tcpip 5555` \n\n\n进入要调试的控制台\n\n```shell\nadb shell\n\nsu\n\nifconfig \n```\n\n连接远程的设备\n`adb connect ip:5555\n\nadb connect 192.168.0.100:5555\n查看正在运行 [查看手机上 app 的包名 几种方式_查看app包名_百年渔翁_肯肯的博客-CSDN博客](https://blog.csdn.net/qq_30007885/article/details/119418593#:~:text=%E6%9F%A5%E7%9C%8B%E6%89%8B%E6%9C%BA%E4%B8%8A%20app%20%E7%9A%84%E5%8C%85%E5%90%8D%20%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%201%20adb,shell%202%20%E6%9F%A5%E8%AF%A2%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%20app%20%E7%9A%84%E5%8C%85%E5%90%8D%203%20%E6%9F%A5%E7%9C%8B%E5%90%AF%E5%8A%A8activity)\n\n```\nC:\\Users\\10630>adb shell dumpsys window | findstr mCurrentFocus\n  mCurrentFocus=Window{c3cd2c3 u0 eu.pokemmo.client/eu.pokemmo.client.AndroidLauncher\n```\n\n eu.pokemmo.client\n\n``",
      "html": "<p>adb （android debugger bridge）\nADB，全称为Android Debug Bridge，即安卓调试桥，是一种功能多样的命令行工具，它允许用户与Android设备（包括模拟器）进行通信。ADB主要用于开发者在开发和调试Android应用程序时，通过电脑对设备进行操作，如安装和卸载应用、复制文件、运行shell命令、查看设备日志等。</p>\n<p>ADB是Android SDK（Software Development Kit）的一部分，它包含三个主要组件：</p>\n<ol>\n<li>客户端（Client）：在开发机器上运行，用于发送命令。用户可以通过命令行终端使用ADB命令。</li>\n<li>守护程序（adbd）：在Android设备上作为后台进程运行，处理来自ADB服务器的命令请求。</li>\n<li>服务器（Server）：在开发机器上运行，管理客户端与守护程序之间的通信。</li>\n</ol>\n<p>使用ADB时，用户可以通过USB数据线或网络（如Wi-Fi）连接设备。一旦连接成功，就可以执行各种ADB命令来管理设备或进行调试。例如，可以使用<code>adb devices</code>列出连接的设备，<code>adb install &#x3C;apk></code>安装应用，<code>adb shell</code>进入设备的shell环境等。ADB是Android开发和测试中不可或缺的工具。</p>\n<p>通过数据线链接\n<code>adb devices</code></p>\n<p>看到连接的设备</p>\n<p>重启adb服务器\n<code>adb tcpip 5555</code></p>\n<p>进入要调试的控制台</p>\n<pre><code class=\"language-shell\">adb shell\n\nsu\n\nifconfig \n</code></pre>\n<p>连接远程的设备\n`adb connect ip:5555</p>\n<p>adb connect 192.168.0.100:5555\n查看正在运行 <a href=\"https://blog.csdn.net/qq_30007885/article/details/119418593#:~:text=%E6%9F%A5%E7%9C%8B%E6%89%8B%E6%9C%BA%E4%B8%8A%20app%20%E7%9A%84%E5%8C%85%E5%90%8D%20%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%201%20adb,shell%202%20%E6%9F%A5%E8%AF%A2%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%20app%20%E7%9A%84%E5%8C%85%E5%90%8D%203%20%E6%9F%A5%E7%9C%8B%E5%90%AF%E5%8A%A8activity\">查看手机上 app 的包名 几种方式_查看app包名_百年渔翁_肯肯的博客-CSDN博客</a></p>\n<pre><code>C:\\Users\\10630>adb shell dumpsys window | findstr mCurrentFocus\n  mCurrentFocus=Window{c3cd2c3 u0 eu.pokemmo.client/eu.pokemmo.client.AndroidLauncher\n</code></pre>\n<p>eu.pokemmo.client</p>\n<p>``</p>"
    },
    "_id": "adb 常用命令1740387002523.md",
    "_raw": {
      "sourceFilePath": "adb 常用命令1740387002523.md",
      "sourceFileName": "adb 常用命令1740387002523.md",
      "sourceFileDir": ".",
      "contentType": "markdown",
      "flattenedPath": "adb 常用命令1740387002523"
    },
    "type": "Post",
    "slug": "adb 常用命令1740387002523",
    "path": "adb 常用命令1740387002523",
    "filePath": "adb 常用命令1740387002523.md",
    "toc": [],
    "structuredData": {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "headline": "什么是ADB? 及其常用命令",
      "datePublished": "2025-02-19T00:00:00.000Z",
      "dateModified": "2025-02-19T00:00:00.000Z",
      "image": "/static/images/twitter-card.png",
      "url": "https://tailwind-nextjs-starter-blog.vercel.app/adb 常用命令1740387002523"
    }
  },
  {
    "title": "git 设置 代理",
    "date": "2025-02-19T00:00:00.000Z",
    "tags": [],
    "body": {
      "raw": "\n### git 设置 代理\n\n[Git 命令行使用代理 VPN - Fany's Blog (fanlumaster.github.io)](https://fanlumaster.github.io/2021/03/23/Git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86-VPN/#:~:text=Git%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%20VPN%202021-03-23%2016%3A41%20-%202021-06-08%2000%3A29,%E8%AE%BE%E7%BD%AE%E5%AE%8C%E4%B9%8B%E5%90%8E%20git%20clone%20%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%8C%E5%8F%91%E7%8E%B0%E9%80%9F%E5%BA%A6%E9%A3%99%E5%88%B0%E4%BA%86%205.5%20mb%2Fs%EF%BC%8C%E8%80%8C%E5%8E%9F%E6%9D%A5%E7%9A%84%E9%80%9F%E5%BA%A6%E6%98%AF%E5%8F%AA%E6%9C%89%E5%8D%81%E5%87%A0%20kb%2Fs%20%E7%9A%84%E3%80%82)\n\n清空代理\n```\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n\n```\ngit config --global http.proxy 'http://127.0.0.1:10080'\ngit config --global https.proxy 'https://127.0.0.1:10080'\n```\n\n### git 设置username email\n\n[使用git config --global设置用户名和邮件_git config --global user.name-CSDN博客](https://blog.csdn.net/sjt19910311/article/details/83685616)",
      "html": "<h3>git 设置 代理</h3>\n<p><a href=\"https://fanlumaster.github.io/2021/03/23/Git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86-VPN/#:~:text=Git%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%20VPN%202021-03-23%2016%3A41%20-%202021-06-08%2000%3A29,%E8%AE%BE%E7%BD%AE%E5%AE%8C%E4%B9%8B%E5%90%8E%20git%20clone%20%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%8C%E5%8F%91%E7%8E%B0%E9%80%9F%E5%BA%A6%E9%A3%99%E5%88%B0%E4%BA%86%205.5%20mb%2Fs%EF%BC%8C%E8%80%8C%E5%8E%9F%E6%9D%A5%E7%9A%84%E9%80%9F%E5%BA%A6%E6%98%AF%E5%8F%AA%E6%9C%89%E5%8D%81%E5%87%A0%20kb%2Fs%20%E7%9A%84%E3%80%82\">Git 命令行使用代理 VPN - Fany's Blog (fanlumaster.github.io)</a></p>\n<p>清空代理</p>\n<pre><code>git config --global --unset http.proxy\ngit config --global --unset https.proxy\n</code></pre>\n<pre><code>git config --global http.proxy 'http://127.0.0.1:10080'\ngit config --global https.proxy 'https://127.0.0.1:10080'\n</code></pre>\n<h3>git 设置username email</h3>\n<p><a href=\"https://blog.csdn.net/sjt19910311/article/details/83685616\">使用git config --global设置用户名和邮件_git config --global user.name-CSDN博客</a></p>"
    },
    "_id": "git 进阶.md",
    "_raw": {
      "sourceFilePath": "git 进阶.md",
      "sourceFileName": "git 进阶.md",
      "sourceFileDir": ".",
      "contentType": "markdown",
      "flattenedPath": "git 进阶"
    },
    "type": "Post",
    "slug": "git 进阶",
    "path": "git 进阶",
    "filePath": "git 进阶.md",
    "toc": [
      {
        "value": "git 设置 代理",
        "url": "#git-设置-代理",
        "depth": 3
      },
      {
        "value": "git 设置username email",
        "url": "#git-设置username-email",
        "depth": 3
      }
    ],
    "structuredData": {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "headline": "git 设置 代理",
      "datePublished": "2025-02-19T00:00:00.000Z",
      "dateModified": "2025-02-19T00:00:00.000Z",
      "image": "/static/images/twitter-card.png",
      "url": "https://tailwind-nextjs-starter-blog.vercel.app/git 进阶"
    }
  },
  {
    "title": "git 设置 代理",
    "date": "2025-02-19T00:00:00.000Z",
    "tags": [],
    "body": {
      "raw": "\n### git 设置 代理\n\n[Git 命令行使用代理 VPN - Fany's Blog (fanlumaster.github.io)](https://fanlumaster.github.io/2021/03/23/Git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86-VPN/#:~:text=Git%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%20VPN%202021-03-23%2016%3A41%20-%202021-06-08%2000%3A29,%E8%AE%BE%E7%BD%AE%E5%AE%8C%E4%B9%8B%E5%90%8E%20git%20clone%20%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%8C%E5%8F%91%E7%8E%B0%E9%80%9F%E5%BA%A6%E9%A3%99%E5%88%B0%E4%BA%86%205.5%20mb%2Fs%EF%BC%8C%E8%80%8C%E5%8E%9F%E6%9D%A5%E7%9A%84%E9%80%9F%E5%BA%A6%E6%98%AF%E5%8F%AA%E6%9C%89%E5%8D%81%E5%87%A0%20kb%2Fs%20%E7%9A%84%E3%80%82)\n\n清空代理\n```\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n\n```\ngit config --global http.proxy 'http://127.0.0.1:10080'\ngit config --global https.proxy 'https://127.0.0.1:10080'\n```\n\n### git 设置username email\n\n[使用git config --global设置用户名和邮件_git config --global user.name-CSDN博客](https://blog.csdn.net/sjt19910311/article/details/83685616)",
      "html": "<h3>git 设置 代理</h3>\n<p><a href=\"https://fanlumaster.github.io/2021/03/23/Git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86-VPN/#:~:text=Git%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%20VPN%202021-03-23%2016%3A41%20-%202021-06-08%2000%3A29,%E8%AE%BE%E7%BD%AE%E5%AE%8C%E4%B9%8B%E5%90%8E%20git%20clone%20%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%8C%E5%8F%91%E7%8E%B0%E9%80%9F%E5%BA%A6%E9%A3%99%E5%88%B0%E4%BA%86%205.5%20mb%2Fs%EF%BC%8C%E8%80%8C%E5%8E%9F%E6%9D%A5%E7%9A%84%E9%80%9F%E5%BA%A6%E6%98%AF%E5%8F%AA%E6%9C%89%E5%8D%81%E5%87%A0%20kb%2Fs%20%E7%9A%84%E3%80%82\">Git 命令行使用代理 VPN - Fany's Blog (fanlumaster.github.io)</a></p>\n<p>清空代理</p>\n<pre><code>git config --global --unset http.proxy\ngit config --global --unset https.proxy\n</code></pre>\n<pre><code>git config --global http.proxy 'http://127.0.0.1:10080'\ngit config --global https.proxy 'https://127.0.0.1:10080'\n</code></pre>\n<h3>git 设置username email</h3>\n<p><a href=\"https://blog.csdn.net/sjt19910311/article/details/83685616\">使用git config --global设置用户名和邮件_git config --global user.name-CSDN博客</a></p>"
    },
    "_id": "git 进阶1740386935906.md",
    "_raw": {
      "sourceFilePath": "git 进阶1740386935906.md",
      "sourceFileName": "git 进阶1740386935906.md",
      "sourceFileDir": ".",
      "contentType": "markdown",
      "flattenedPath": "git 进阶1740386935906"
    },
    "type": "Post",
    "slug": "git 进阶1740386935906",
    "path": "git 进阶1740386935906",
    "filePath": "git 进阶1740386935906.md",
    "toc": [
      {
        "value": "git 设置 代理",
        "url": "#git-设置-代理",
        "depth": 3
      },
      {
        "value": "git 设置username email",
        "url": "#git-设置username-email",
        "depth": 3
      }
    ],
    "structuredData": {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "headline": "git 设置 代理",
      "datePublished": "2025-02-19T00:00:00.000Z",
      "dateModified": "2025-02-19T00:00:00.000Z",
      "image": "/static/images/twitter-card.png",
      "url": "https://tailwind-nextjs-starter-blog.vercel.app/git 进阶1740386935906"
    }
  },
  {
    "title": "git 设置 代理",
    "date": "2025-02-19T00:00:00.000Z",
    "tags": [],
    "body": {
      "raw": "\n### git 设置 代理\n\n[Git 命令行使用代理 VPN - Fany's Blog (fanlumaster.github.io)](https://fanlumaster.github.io/2021/03/23/Git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86-VPN/#:~:text=Git%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%20VPN%202021-03-23%2016%3A41%20-%202021-06-08%2000%3A29,%E8%AE%BE%E7%BD%AE%E5%AE%8C%E4%B9%8B%E5%90%8E%20git%20clone%20%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%8C%E5%8F%91%E7%8E%B0%E9%80%9F%E5%BA%A6%E9%A3%99%E5%88%B0%E4%BA%86%205.5%20mb%2Fs%EF%BC%8C%E8%80%8C%E5%8E%9F%E6%9D%A5%E7%9A%84%E9%80%9F%E5%BA%A6%E6%98%AF%E5%8F%AA%E6%9C%89%E5%8D%81%E5%87%A0%20kb%2Fs%20%E7%9A%84%E3%80%82)\n\n清空代理\n```\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n\n```\ngit config --global http.proxy 'http://127.0.0.1:10080'\ngit config --global https.proxy 'https://127.0.0.1:10080'\n```\n\n### git 设置username email\n\n[使用git config --global设置用户名和邮件_git config --global user.name-CSDN博客](https://blog.csdn.net/sjt19910311/article/details/83685616)",
      "html": "<h3>git 设置 代理</h3>\n<p><a href=\"https://fanlumaster.github.io/2021/03/23/Git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86-VPN/#:~:text=Git%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%20VPN%202021-03-23%2016%3A41%20-%202021-06-08%2000%3A29,%E8%AE%BE%E7%BD%AE%E5%AE%8C%E4%B9%8B%E5%90%8E%20git%20clone%20%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%8C%E5%8F%91%E7%8E%B0%E9%80%9F%E5%BA%A6%E9%A3%99%E5%88%B0%E4%BA%86%205.5%20mb%2Fs%EF%BC%8C%E8%80%8C%E5%8E%9F%E6%9D%A5%E7%9A%84%E9%80%9F%E5%BA%A6%E6%98%AF%E5%8F%AA%E6%9C%89%E5%8D%81%E5%87%A0%20kb%2Fs%20%E7%9A%84%E3%80%82\">Git 命令行使用代理 VPN - Fany's Blog (fanlumaster.github.io)</a></p>\n<p>清空代理</p>\n<pre><code>git config --global --unset http.proxy\ngit config --global --unset https.proxy\n</code></pre>\n<pre><code>git config --global http.proxy 'http://127.0.0.1:10080'\ngit config --global https.proxy 'https://127.0.0.1:10080'\n</code></pre>\n<h3>git 设置username email</h3>\n<p><a href=\"https://blog.csdn.net/sjt19910311/article/details/83685616\">使用git config --global设置用户名和邮件_git config --global user.name-CSDN博客</a></p>"
    },
    "_id": "git 进阶1740387002539.md",
    "_raw": {
      "sourceFilePath": "git 进阶1740387002539.md",
      "sourceFileName": "git 进阶1740387002539.md",
      "sourceFileDir": ".",
      "contentType": "markdown",
      "flattenedPath": "git 进阶1740387002539"
    },
    "type": "Post",
    "slug": "git 进阶1740387002539",
    "path": "git 进阶1740387002539",
    "filePath": "git 进阶1740387002539.md",
    "toc": [
      {
        "value": "git 设置 代理",
        "url": "#git-设置-代理",
        "depth": 3
      },
      {
        "value": "git 设置username email",
        "url": "#git-设置username-email",
        "depth": 3
      }
    ],
    "structuredData": {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "headline": "git 设置 代理",
      "datePublished": "2025-02-19T00:00:00.000Z",
      "dateModified": "2025-02-19T00:00:00.000Z",
      "image": "/static/images/twitter-card.png",
      "url": "https://tailwind-nextjs-starter-blog.vercel.app/git 进阶1740387002539"
    }
  },
  {
    "title": "krita comfyUI 插件安装教程",
    "date": "2025-02-19T00:00:00.000Z",
    "tags": [],
    "body": {
      "raw": "\n要在 Krita 中使用 ComfyUI LCM（Live Canvas Mode）进行实时绘画，你可以按照以下步骤操作：\n[ComfyUI Setup · Acly/krita-ai-diffusion Wiki (github.com)](https://github.com/Acly/krita-ai-diffusion/wiki/ComfyUI-Setup)\n### 1. 安装 Krita 和 ComfyUI\n\n确保你已经安装了 Krita 和 ComfyUI。如果没有安装，可以从以下链接下载：\n\n- [下载后页面 | Krita](https://krita.org/zh-cn/post-download/)\n- [Release v0.0.2 · comfyanonymous/ComfyUI (github.com)](https://github.com/comfyanonymous/ComfyUI/releases/tag/v0.0.2)\n![Pasted image 20240727151823](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727151823.png)\n### 2. 安装 LCM 插件\n\n你需要安装 Krita 的 Live Canvas Mode 插件。可以通过以下步骤操作：\n\n1. **下载 LCM 插件**：\n    \n    - 访问 LCM 插件的官方网站或 GitHub 页面，下载最新版本的插件包。\n\n[Releases · Acly/krita-ai-diffusion (github.com)](https://github.com/Acly/krita-ai-diffusion/releases)\n1. **安装插件**：\n    ![Pasted image 20240727154721](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727154721.png)\n  [Krita+ComfyUI+LCM 实时AI绘画一键整合包! - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/668305270)\n\n### 3. 启动 ComfyUI LCM\n\n1. **启动 Krita**：\n    \n    - 打开 Krita，并创建一个新的画布或者打开现有的项目。\n2. **开启实时绘画模式**：\n按照下面教程：\n    https://www.bilibili.com/video/BV1au4y1P7ZS?vd_source=27aad4b0784cb53231c2baaed62a0b35\n    - 在 Krita 中，找到 LCM 插件的工具栏按钮，点击它以开启实时绘画模式。\n    - 你应该能够在画布上看到实时更新的绘画效果。\n配置comfyUI\n![Pasted image 20240727155503](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727155503.png)\n注意连接过程会提示你，缺少相应的依赖，你只要更加指示去安装。\n去对应的github，安装相关模型：\n[ComfyUI Setup · Acly/krita-ai-diffusion Wiki (github.com)](https://github.com/Acly/krita-ai-diffusion/wiki/ComfyUI-Setup)\n![Pasted image 20240727160612](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727160612.png)\n你也可以使用如下： 【SD1.5 我直接使用百度网盘中的】\nhttps://pan.baidu.com/s/1TMSdDXiBCJFQQJiIjuqNZg?pwd=xtcd\n配置完之后的文件如下：\n![Pasted image 20240728002745](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002745.png)\n![Pasted image 20240728001325](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001325.png)\n![Pasted image 20240728001408](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001408.png)\n![Pasted image 20240728001657](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001657.png)\n![Pasted image 20240728002013](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002013.png)\n![Pasted image 20240728002908](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002908.png)\n![Pasted image 20240728002940](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002940.png)\n\n### 4. 使用实时预览\n\n1. **配置实时预览**：\n    \n    - 在 ComfyUI 中，进入设置菜单，确保实时预览（Real-time Preview）选项已开启。\n2. **绘画和实时预览**：\n    \n    - 在 Krita 中进行绘画时，ComfyUI LCM 会实时捕捉你的绘画动作并在预览窗口中显示。\n    - 你可以调整 ComfyUI 的设置，以优化实时预览的性能和质量。\n\n### 5. 保存和导出\n\n1. **保存项目**：\n    \n    - 在 Krita 中保存你的项目，确保你的工作不会丢失。\n2. **导出预览**：\n    \n    - 如果需要，你可以从 ComfyUI 中导出实时预览的结果，保存为图片或视频文件。\n\n### 注意事项\n\n- 确保你的电脑性能足够强大，因为实时预览和绘画同时进行可能需要较高的计算资源。\n- 如果遇到任何问题，可以查阅 Krita 和 ComfyUI 的官方文档或社区论坛，获取更多帮助和支持。",
      "html": "<p>要在 Krita 中使用 ComfyUI LCM（Live Canvas Mode）进行实时绘画，你可以按照以下步骤操作：\n<a href=\"https://github.com/Acly/krita-ai-diffusion/wiki/ComfyUI-Setup\">ComfyUI Setup · Acly/krita-ai-diffusion Wiki (github.com)</a></p>\n<h3>1. 安装 Krita 和 ComfyUI</h3>\n<p>确保你已经安装了 Krita 和 ComfyUI。如果没有安装，可以从以下链接下载：</p>\n<ul>\n<li><a href=\"https://krita.org/zh-cn/post-download/\">下载后页面 | Krita</a></li>\n<li><a href=\"https://github.com/comfyanonymous/ComfyUI/releases/tag/v0.0.2\">Release v0.0.2 · comfyanonymous/ComfyUI (github.com)</a>\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727151823.png\" alt=\"Pasted image 20240727151823\"></li>\n</ul>\n<h3>2. 安装 LCM 插件</h3>\n<p>你需要安装 Krita 的 Live Canvas Mode 插件。可以通过以下步骤操作：</p>\n<ol>\n<li>\n<p><strong>下载 LCM 插件</strong>：</p>\n<ul>\n<li>访问 LCM 插件的官方网站或 GitHub 页面，下载最新版本的插件包。</li>\n</ul>\n</li>\n</ol>\n<p><a href=\"https://github.com/Acly/krita-ai-diffusion/releases\">Releases · Acly/krita-ai-diffusion (github.com)</a></p>\n<ol>\n<li><strong>安装插件</strong>：\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727154721.png\" alt=\"Pasted image 20240727154721\">\n<a href=\"https://zhuanlan.zhihu.com/p/668305270\">Krita+ComfyUI+LCM 实时AI绘画一键整合包! - 知乎 (zhihu.com)</a></li>\n</ol>\n<h3>3. 启动 ComfyUI LCM</h3>\n<ol>\n<li>\n<p><strong>启动 Krita</strong>：</p>\n<ul>\n<li>打开 Krita，并创建一个新的画布或者打开现有的项目。</li>\n</ul>\n</li>\n<li>\n<p><strong>开启实时绘画模式</strong>：\n按照下面教程：\nhttps://www.bilibili.com/video/BV1au4y1P7ZS?vd_source=27aad4b0784cb53231c2baaed62a0b35</p>\n<ul>\n<li>在 Krita 中，找到 LCM 插件的工具栏按钮，点击它以开启实时绘画模式。</li>\n<li>你应该能够在画布上看到实时更新的绘画效果。\n配置comfyUI\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727155503.png\" alt=\"Pasted image 20240727155503\">\n注意连接过程会提示你，缺少相应的依赖，你只要更加指示去安装。\n去对应的github，安装相关模型：\n<a href=\"https://github.com/Acly/krita-ai-diffusion/wiki/ComfyUI-Setup\">ComfyUI Setup · Acly/krita-ai-diffusion Wiki (github.com)</a>\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727160612.png\" alt=\"Pasted image 20240727160612\">\n你也可以使用如下： 【SD1.5 我直接使用百度网盘中的】\nhttps://pan.baidu.com/s/1TMSdDXiBCJFQQJiIjuqNZg?pwd=xtcd\n配置完之后的文件如下：\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002745.png\" alt=\"Pasted image 20240728002745\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001325.png\" alt=\"Pasted image 20240728001325\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001408.png\" alt=\"Pasted image 20240728001408\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001657.png\" alt=\"Pasted image 20240728001657\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002013.png\" alt=\"Pasted image 20240728002013\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002908.png\" alt=\"Pasted image 20240728002908\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002940.png\" alt=\"Pasted image 20240728002940\"></li>\n</ul>\n</li>\n</ol>\n<h3>4. 使用实时预览</h3>\n<ol>\n<li>\n<p><strong>配置实时预览</strong>：</p>\n<ul>\n<li>在 ComfyUI 中，进入设置菜单，确保实时预览（Real-time Preview）选项已开启。</li>\n</ul>\n</li>\n<li>\n<p><strong>绘画和实时预览</strong>：</p>\n<ul>\n<li>在 Krita 中进行绘画时，ComfyUI LCM 会实时捕捉你的绘画动作并在预览窗口中显示。</li>\n<li>你可以调整 ComfyUI 的设置，以优化实时预览的性能和质量。</li>\n</ul>\n</li>\n</ol>\n<h3>5. 保存和导出</h3>\n<ol>\n<li>\n<p><strong>保存项目</strong>：</p>\n<ul>\n<li>在 Krita 中保存你的项目，确保你的工作不会丢失。</li>\n</ul>\n</li>\n<li>\n<p><strong>导出预览</strong>：</p>\n<ul>\n<li>如果需要，你可以从 ComfyUI 中导出实时预览的结果，保存为图片或视频文件。</li>\n</ul>\n</li>\n</ol>\n<h3>注意事项</h3>\n<ul>\n<li>确保你的电脑性能足够强大，因为实时预览和绘画同时进行可能需要较高的计算资源。</li>\n<li>如果遇到任何问题，可以查阅 Krita 和 ComfyUI 的官方文档或社区论坛，获取更多帮助和支持。</li>\n</ul>"
    },
    "_id": "krita comfyUI LCM 的实时绘画安装教程.md",
    "_raw": {
      "sourceFilePath": "krita comfyUI LCM 的实时绘画安装教程.md",
      "sourceFileName": "krita comfyUI LCM 的实时绘画安装教程.md",
      "sourceFileDir": ".",
      "contentType": "markdown",
      "flattenedPath": "krita comfyUI LCM 的实时绘画安装教程"
    },
    "type": "Post",
    "slug": "krita comfyUI LCM 的实时绘画安装教程",
    "path": "krita comfyUI LCM 的实时绘画安装教程",
    "filePath": "krita comfyUI LCM 的实时绘画安装教程.md",
    "toc": [
      {
        "value": "1. 安装 Krita 和 ComfyUI",
        "url": "#1-安装-krita-和-comfyui",
        "depth": 3
      },
      {
        "value": "2. 安装 LCM 插件",
        "url": "#2-安装-lcm-插件",
        "depth": 3
      },
      {
        "value": "3. 启动 ComfyUI LCM",
        "url": "#3-启动-comfyui-lcm",
        "depth": 3
      },
      {
        "value": "4. 使用实时预览",
        "url": "#4-使用实时预览",
        "depth": 3
      },
      {
        "value": "5. 保存和导出",
        "url": "#5-保存和导出",
        "depth": 3
      },
      {
        "value": "注意事项",
        "url": "#注意事项",
        "depth": 3
      }
    ],
    "structuredData": {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "headline": "krita comfyUI 插件安装教程",
      "datePublished": "2025-02-19T00:00:00.000Z",
      "dateModified": "2025-02-19T00:00:00.000Z",
      "image": "/static/images/twitter-card.png",
      "url": "https://tailwind-nextjs-starter-blog.vercel.app/krita comfyUI LCM 的实时绘画安装教程"
    }
  },
  {
    "title": "krita comfyUI 插件安装教程",
    "date": "2025-02-19T00:00:00.000Z",
    "tags": [],
    "body": {
      "raw": "\n要在 Krita 中使用 ComfyUI LCM（Live Canvas Mode）进行实时绘画，你可以按照以下步骤操作：\n[ComfyUI Setup · Acly/krita-ai-diffusion Wiki (github.com)](https://github.com/Acly/krita-ai-diffusion/wiki/ComfyUI-Setup)\n### 1. 安装 Krita 和 ComfyUI\n\n确保你已经安装了 Krita 和 ComfyUI。如果没有安装，可以从以下链接下载：\n\n- [下载后页面 | Krita](https://krita.org/zh-cn/post-download/)\n- [Release v0.0.2 · comfyanonymous/ComfyUI (github.com)](https://github.com/comfyanonymous/ComfyUI/releases/tag/v0.0.2)\n![Pasted image 20240727151823](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727151823.png)\n### 2. 安装 LCM 插件\n\n你需要安装 Krita 的 Live Canvas Mode 插件。可以通过以下步骤操作：\n\n1. **下载 LCM 插件**：\n    \n    - 访问 LCM 插件的官方网站或 GitHub 页面，下载最新版本的插件包。\n\n[Releases · Acly/krita-ai-diffusion (github.com)](https://github.com/Acly/krita-ai-diffusion/releases)\n1. **安装插件**：\n    ![Pasted image 20240727154721](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727154721.png)\n  [Krita+ComfyUI+LCM 实时AI绘画一键整合包! - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/668305270)\n\n### 3. 启动 ComfyUI LCM\n\n1. **启动 Krita**：\n    \n    - 打开 Krita，并创建一个新的画布或者打开现有的项目。\n2. **开启实时绘画模式**：\n按照下面教程：\n    https://www.bilibili.com/video/BV1au4y1P7ZS?vd_source=27aad4b0784cb53231c2baaed62a0b35\n    - 在 Krita 中，找到 LCM 插件的工具栏按钮，点击它以开启实时绘画模式。\n    - 你应该能够在画布上看到实时更新的绘画效果。\n配置comfyUI\n![Pasted image 20240727155503](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727155503.png)\n注意连接过程会提示你，缺少相应的依赖，你只要更加指示去安装。\n去对应的github，安装相关模型：\n[ComfyUI Setup · Acly/krita-ai-diffusion Wiki (github.com)](https://github.com/Acly/krita-ai-diffusion/wiki/ComfyUI-Setup)\n![Pasted image 20240727160612](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727160612.png)\n你也可以使用如下： 【SD1.5 我直接使用百度网盘中的】\nhttps://pan.baidu.com/s/1TMSdDXiBCJFQQJiIjuqNZg?pwd=xtcd\n配置完之后的文件如下：\n![Pasted image 20240728002745](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002745.png)\n![Pasted image 20240728001325](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001325.png)\n![Pasted image 20240728001408](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001408.png)\n![Pasted image 20240728001657](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001657.png)\n![Pasted image 20240728002013](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002013.png)\n![Pasted image 20240728002908](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002908.png)\n![Pasted image 20240728002940](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002940.png)\n\n### 4. 使用实时预览\n\n1. **配置实时预览**：\n    \n    - 在 ComfyUI 中，进入设置菜单，确保实时预览（Real-time Preview）选项已开启。\n2. **绘画和实时预览**：\n    \n    - 在 Krita 中进行绘画时，ComfyUI LCM 会实时捕捉你的绘画动作并在预览窗口中显示。\n    - 你可以调整 ComfyUI 的设置，以优化实时预览的性能和质量。\n\n### 5. 保存和导出\n\n1. **保存项目**：\n    \n    - 在 Krita 中保存你的项目，确保你的工作不会丢失。\n2. **导出预览**：\n    \n    - 如果需要，你可以从 ComfyUI 中导出实时预览的结果，保存为图片或视频文件。\n\n### 注意事项\n\n- 确保你的电脑性能足够强大，因为实时预览和绘画同时进行可能需要较高的计算资源。\n- 如果遇到任何问题，可以查阅 Krita 和 ComfyUI 的官方文档或社区论坛，获取更多帮助和支持。",
      "html": "<p>要在 Krita 中使用 ComfyUI LCM（Live Canvas Mode）进行实时绘画，你可以按照以下步骤操作：\n<a href=\"https://github.com/Acly/krita-ai-diffusion/wiki/ComfyUI-Setup\">ComfyUI Setup · Acly/krita-ai-diffusion Wiki (github.com)</a></p>\n<h3>1. 安装 Krita 和 ComfyUI</h3>\n<p>确保你已经安装了 Krita 和 ComfyUI。如果没有安装，可以从以下链接下载：</p>\n<ul>\n<li><a href=\"https://krita.org/zh-cn/post-download/\">下载后页面 | Krita</a></li>\n<li><a href=\"https://github.com/comfyanonymous/ComfyUI/releases/tag/v0.0.2\">Release v0.0.2 · comfyanonymous/ComfyUI (github.com)</a>\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727151823.png\" alt=\"Pasted image 20240727151823\"></li>\n</ul>\n<h3>2. 安装 LCM 插件</h3>\n<p>你需要安装 Krita 的 Live Canvas Mode 插件。可以通过以下步骤操作：</p>\n<ol>\n<li>\n<p><strong>下载 LCM 插件</strong>：</p>\n<ul>\n<li>访问 LCM 插件的官方网站或 GitHub 页面，下载最新版本的插件包。</li>\n</ul>\n</li>\n</ol>\n<p><a href=\"https://github.com/Acly/krita-ai-diffusion/releases\">Releases · Acly/krita-ai-diffusion (github.com)</a></p>\n<ol>\n<li><strong>安装插件</strong>：\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727154721.png\" alt=\"Pasted image 20240727154721\">\n<a href=\"https://zhuanlan.zhihu.com/p/668305270\">Krita+ComfyUI+LCM 实时AI绘画一键整合包! - 知乎 (zhihu.com)</a></li>\n</ol>\n<h3>3. 启动 ComfyUI LCM</h3>\n<ol>\n<li>\n<p><strong>启动 Krita</strong>：</p>\n<ul>\n<li>打开 Krita，并创建一个新的画布或者打开现有的项目。</li>\n</ul>\n</li>\n<li>\n<p><strong>开启实时绘画模式</strong>：\n按照下面教程：\nhttps://www.bilibili.com/video/BV1au4y1P7ZS?vd_source=27aad4b0784cb53231c2baaed62a0b35</p>\n<ul>\n<li>在 Krita 中，找到 LCM 插件的工具栏按钮，点击它以开启实时绘画模式。</li>\n<li>你应该能够在画布上看到实时更新的绘画效果。\n配置comfyUI\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727155503.png\" alt=\"Pasted image 20240727155503\">\n注意连接过程会提示你，缺少相应的依赖，你只要更加指示去安装。\n去对应的github，安装相关模型：\n<a href=\"https://github.com/Acly/krita-ai-diffusion/wiki/ComfyUI-Setup\">ComfyUI Setup · Acly/krita-ai-diffusion Wiki (github.com)</a>\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727160612.png\" alt=\"Pasted image 20240727160612\">\n你也可以使用如下： 【SD1.5 我直接使用百度网盘中的】\nhttps://pan.baidu.com/s/1TMSdDXiBCJFQQJiIjuqNZg?pwd=xtcd\n配置完之后的文件如下：\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002745.png\" alt=\"Pasted image 20240728002745\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001325.png\" alt=\"Pasted image 20240728001325\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001408.png\" alt=\"Pasted image 20240728001408\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001657.png\" alt=\"Pasted image 20240728001657\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002013.png\" alt=\"Pasted image 20240728002013\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002908.png\" alt=\"Pasted image 20240728002908\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002940.png\" alt=\"Pasted image 20240728002940\"></li>\n</ul>\n</li>\n</ol>\n<h3>4. 使用实时预览</h3>\n<ol>\n<li>\n<p><strong>配置实时预览</strong>：</p>\n<ul>\n<li>在 ComfyUI 中，进入设置菜单，确保实时预览（Real-time Preview）选项已开启。</li>\n</ul>\n</li>\n<li>\n<p><strong>绘画和实时预览</strong>：</p>\n<ul>\n<li>在 Krita 中进行绘画时，ComfyUI LCM 会实时捕捉你的绘画动作并在预览窗口中显示。</li>\n<li>你可以调整 ComfyUI 的设置，以优化实时预览的性能和质量。</li>\n</ul>\n</li>\n</ol>\n<h3>5. 保存和导出</h3>\n<ol>\n<li>\n<p><strong>保存项目</strong>：</p>\n<ul>\n<li>在 Krita 中保存你的项目，确保你的工作不会丢失。</li>\n</ul>\n</li>\n<li>\n<p><strong>导出预览</strong>：</p>\n<ul>\n<li>如果需要，你可以从 ComfyUI 中导出实时预览的结果，保存为图片或视频文件。</li>\n</ul>\n</li>\n</ol>\n<h3>注意事项</h3>\n<ul>\n<li>确保你的电脑性能足够强大，因为实时预览和绘画同时进行可能需要较高的计算资源。</li>\n<li>如果遇到任何问题，可以查阅 Krita 和 ComfyUI 的官方文档或社区论坛，获取更多帮助和支持。</li>\n</ul>"
    },
    "_id": "krita comfyUI LCM 的实时绘画安装教程1740386935926.md",
    "_raw": {
      "sourceFilePath": "krita comfyUI LCM 的实时绘画安装教程1740386935926.md",
      "sourceFileName": "krita comfyUI LCM 的实时绘画安装教程1740386935926.md",
      "sourceFileDir": ".",
      "contentType": "markdown",
      "flattenedPath": "krita comfyUI LCM 的实时绘画安装教程1740386935926"
    },
    "type": "Post",
    "slug": "krita comfyUI LCM 的实时绘画安装教程1740386935926",
    "path": "krita comfyUI LCM 的实时绘画安装教程1740386935926",
    "filePath": "krita comfyUI LCM 的实时绘画安装教程1740386935926.md",
    "toc": [
      {
        "value": "1. 安装 Krita 和 ComfyUI",
        "url": "#1-安装-krita-和-comfyui",
        "depth": 3
      },
      {
        "value": "2. 安装 LCM 插件",
        "url": "#2-安装-lcm-插件",
        "depth": 3
      },
      {
        "value": "3. 启动 ComfyUI LCM",
        "url": "#3-启动-comfyui-lcm",
        "depth": 3
      },
      {
        "value": "4. 使用实时预览",
        "url": "#4-使用实时预览",
        "depth": 3
      },
      {
        "value": "5. 保存和导出",
        "url": "#5-保存和导出",
        "depth": 3
      },
      {
        "value": "注意事项",
        "url": "#注意事项",
        "depth": 3
      }
    ],
    "structuredData": {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "headline": "krita comfyUI 插件安装教程",
      "datePublished": "2025-02-19T00:00:00.000Z",
      "dateModified": "2025-02-19T00:00:00.000Z",
      "image": "/static/images/twitter-card.png",
      "url": "https://tailwind-nextjs-starter-blog.vercel.app/krita comfyUI LCM 的实时绘画安装教程1740386935926"
    }
  },
  {
    "title": "krita comfyUI 插件安装教程",
    "date": "2025-02-19T00:00:00.000Z",
    "tags": [],
    "body": {
      "raw": "\n要在 Krita 中使用 ComfyUI LCM（Live Canvas Mode）进行实时绘画，你可以按照以下步骤操作：\n[ComfyUI Setup · Acly/krita-ai-diffusion Wiki (github.com)](https://github.com/Acly/krita-ai-diffusion/wiki/ComfyUI-Setup)\n### 1. 安装 Krita 和 ComfyUI\n\n确保你已经安装了 Krita 和 ComfyUI。如果没有安装，可以从以下链接下载：\n\n- [下载后页面 | Krita](https://krita.org/zh-cn/post-download/)\n- [Release v0.0.2 · comfyanonymous/ComfyUI (github.com)](https://github.com/comfyanonymous/ComfyUI/releases/tag/v0.0.2)\n![Pasted image 20240727151823](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727151823.png)\n### 2. 安装 LCM 插件\n\n你需要安装 Krita 的 Live Canvas Mode 插件。可以通过以下步骤操作：\n\n1. **下载 LCM 插件**：\n    \n    - 访问 LCM 插件的官方网站或 GitHub 页面，下载最新版本的插件包。\n\n[Releases · Acly/krita-ai-diffusion (github.com)](https://github.com/Acly/krita-ai-diffusion/releases)\n1. **安装插件**：\n    ![Pasted image 20240727154721](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727154721.png)\n  [Krita+ComfyUI+LCM 实时AI绘画一键整合包! - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/668305270)\n\n### 3. 启动 ComfyUI LCM\n\n1. **启动 Krita**：\n    \n    - 打开 Krita，并创建一个新的画布或者打开现有的项目。\n2. **开启实时绘画模式**：\n按照下面教程：\n    https://www.bilibili.com/video/BV1au4y1P7ZS?vd_source=27aad4b0784cb53231c2baaed62a0b35\n    - 在 Krita 中，找到 LCM 插件的工具栏按钮，点击它以开启实时绘画模式。\n    - 你应该能够在画布上看到实时更新的绘画效果。\n配置comfyUI\n![Pasted image 20240727155503](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727155503.png)\n注意连接过程会提示你，缺少相应的依赖，你只要更加指示去安装。\n去对应的github，安装相关模型：\n[ComfyUI Setup · Acly/krita-ai-diffusion Wiki (github.com)](https://github.com/Acly/krita-ai-diffusion/wiki/ComfyUI-Setup)\n![Pasted image 20240727160612](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727160612.png)\n你也可以使用如下： 【SD1.5 我直接使用百度网盘中的】\nhttps://pan.baidu.com/s/1TMSdDXiBCJFQQJiIjuqNZg?pwd=xtcd\n配置完之后的文件如下：\n![Pasted image 20240728002745](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002745.png)\n![Pasted image 20240728001325](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001325.png)\n![Pasted image 20240728001408](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001408.png)\n![Pasted image 20240728001657](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001657.png)\n![Pasted image 20240728002013](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002013.png)\n![Pasted image 20240728002908](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002908.png)\n![Pasted image 20240728002940](https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002940.png)\n\n### 4. 使用实时预览\n\n1. **配置实时预览**：\n    \n    - 在 ComfyUI 中，进入设置菜单，确保实时预览（Real-time Preview）选项已开启。\n2. **绘画和实时预览**：\n    \n    - 在 Krita 中进行绘画时，ComfyUI LCM 会实时捕捉你的绘画动作并在预览窗口中显示。\n    - 你可以调整 ComfyUI 的设置，以优化实时预览的性能和质量。\n\n### 5. 保存和导出\n\n1. **保存项目**：\n    \n    - 在 Krita 中保存你的项目，确保你的工作不会丢失。\n2. **导出预览**：\n    \n    - 如果需要，你可以从 ComfyUI 中导出实时预览的结果，保存为图片或视频文件。\n\n### 注意事项\n\n- 确保你的电脑性能足够强大，因为实时预览和绘画同时进行可能需要较高的计算资源。\n- 如果遇到任何问题，可以查阅 Krita 和 ComfyUI 的官方文档或社区论坛，获取更多帮助和支持。",
      "html": "<p>要在 Krita 中使用 ComfyUI LCM（Live Canvas Mode）进行实时绘画，你可以按照以下步骤操作：\n<a href=\"https://github.com/Acly/krita-ai-diffusion/wiki/ComfyUI-Setup\">ComfyUI Setup · Acly/krita-ai-diffusion Wiki (github.com)</a></p>\n<h3>1. 安装 Krita 和 ComfyUI</h3>\n<p>确保你已经安装了 Krita 和 ComfyUI。如果没有安装，可以从以下链接下载：</p>\n<ul>\n<li><a href=\"https://krita.org/zh-cn/post-download/\">下载后页面 | Krita</a></li>\n<li><a href=\"https://github.com/comfyanonymous/ComfyUI/releases/tag/v0.0.2\">Release v0.0.2 · comfyanonymous/ComfyUI (github.com)</a>\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727151823.png\" alt=\"Pasted image 20240727151823\"></li>\n</ul>\n<h3>2. 安装 LCM 插件</h3>\n<p>你需要安装 Krita 的 Live Canvas Mode 插件。可以通过以下步骤操作：</p>\n<ol>\n<li>\n<p><strong>下载 LCM 插件</strong>：</p>\n<ul>\n<li>访问 LCM 插件的官方网站或 GitHub 页面，下载最新版本的插件包。</li>\n</ul>\n</li>\n</ol>\n<p><a href=\"https://github.com/Acly/krita-ai-diffusion/releases\">Releases · Acly/krita-ai-diffusion (github.com)</a></p>\n<ol>\n<li><strong>安装插件</strong>：\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727154721.png\" alt=\"Pasted image 20240727154721\">\n<a href=\"https://zhuanlan.zhihu.com/p/668305270\">Krita+ComfyUI+LCM 实时AI绘画一键整合包! - 知乎 (zhihu.com)</a></li>\n</ol>\n<h3>3. 启动 ComfyUI LCM</h3>\n<ol>\n<li>\n<p><strong>启动 Krita</strong>：</p>\n<ul>\n<li>打开 Krita，并创建一个新的画布或者打开现有的项目。</li>\n</ul>\n</li>\n<li>\n<p><strong>开启实时绘画模式</strong>：\n按照下面教程：\nhttps://www.bilibili.com/video/BV1au4y1P7ZS?vd_source=27aad4b0784cb53231c2baaed62a0b35</p>\n<ul>\n<li>在 Krita 中，找到 LCM 插件的工具栏按钮，点击它以开启实时绘画模式。</li>\n<li>你应该能够在画布上看到实时更新的绘画效果。\n配置comfyUI\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727155503.png\" alt=\"Pasted image 20240727155503\">\n注意连接过程会提示你，缺少相应的依赖，你只要更加指示去安装。\n去对应的github，安装相关模型：\n<a href=\"https://github.com/Acly/krita-ai-diffusion/wiki/ComfyUI-Setup\">ComfyUI Setup · Acly/krita-ai-diffusion Wiki (github.com)</a>\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240727160612.png\" alt=\"Pasted image 20240727160612\">\n你也可以使用如下： 【SD1.5 我直接使用百度网盘中的】\nhttps://pan.baidu.com/s/1TMSdDXiBCJFQQJiIjuqNZg?pwd=xtcd\n配置完之后的文件如下：\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002745.png\" alt=\"Pasted image 20240728002745\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001325.png\" alt=\"Pasted image 20240728001325\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001408.png\" alt=\"Pasted image 20240728001408\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728001657.png\" alt=\"Pasted image 20240728001657\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002013.png\" alt=\"Pasted image 20240728002013\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002908.png\" alt=\"Pasted image 20240728002908\">\n<img src=\"https://picgo-1300491698.cos.ap-nanjing.myqcloud.com/Pasted%20image%2020240728002940.png\" alt=\"Pasted image 20240728002940\"></li>\n</ul>\n</li>\n</ol>\n<h3>4. 使用实时预览</h3>\n<ol>\n<li>\n<p><strong>配置实时预览</strong>：</p>\n<ul>\n<li>在 ComfyUI 中，进入设置菜单，确保实时预览（Real-time Preview）选项已开启。</li>\n</ul>\n</li>\n<li>\n<p><strong>绘画和实时预览</strong>：</p>\n<ul>\n<li>在 Krita 中进行绘画时，ComfyUI LCM 会实时捕捉你的绘画动作并在预览窗口中显示。</li>\n<li>你可以调整 ComfyUI 的设置，以优化实时预览的性能和质量。</li>\n</ul>\n</li>\n</ol>\n<h3>5. 保存和导出</h3>\n<ol>\n<li>\n<p><strong>保存项目</strong>：</p>\n<ul>\n<li>在 Krita 中保存你的项目，确保你的工作不会丢失。</li>\n</ul>\n</li>\n<li>\n<p><strong>导出预览</strong>：</p>\n<ul>\n<li>如果需要，你可以从 ComfyUI 中导出实时预览的结果，保存为图片或视频文件。</li>\n</ul>\n</li>\n</ol>\n<h3>注意事项</h3>\n<ul>\n<li>确保你的电脑性能足够强大，因为实时预览和绘画同时进行可能需要较高的计算资源。</li>\n<li>如果遇到任何问题，可以查阅 Krita 和 ComfyUI 的官方文档或社区论坛，获取更多帮助和支持。</li>\n</ul>"
    },
    "_id": "krita comfyUI LCM 的实时绘画安装教程1740387002546.md",
    "_raw": {
      "sourceFilePath": "krita comfyUI LCM 的实时绘画安装教程1740387002546.md",
      "sourceFileName": "krita comfyUI LCM 的实时绘画安装教程1740387002546.md",
      "sourceFileDir": ".",
      "contentType": "markdown",
      "flattenedPath": "krita comfyUI LCM 的实时绘画安装教程1740387002546"
    },
    "type": "Post",
    "slug": "krita comfyUI LCM 的实时绘画安装教程1740387002546",
    "path": "krita comfyUI LCM 的实时绘画安装教程1740387002546",
    "filePath": "krita comfyUI LCM 的实时绘画安装教程1740387002546.md",
    "toc": [
      {
        "value": "1. 安装 Krita 和 ComfyUI",
        "url": "#1-安装-krita-和-comfyui",
        "depth": 3
      },
      {
        "value": "2. 安装 LCM 插件",
        "url": "#2-安装-lcm-插件",
        "depth": 3
      },
      {
        "value": "3. 启动 ComfyUI LCM",
        "url": "#3-启动-comfyui-lcm",
        "depth": 3
      },
      {
        "value": "4. 使用实时预览",
        "url": "#4-使用实时预览",
        "depth": 3
      },
      {
        "value": "5. 保存和导出",
        "url": "#5-保存和导出",
        "depth": 3
      },
      {
        "value": "注意事项",
        "url": "#注意事项",
        "depth": 3
      }
    ],
    "structuredData": {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "headline": "krita comfyUI 插件安装教程",
      "datePublished": "2025-02-19T00:00:00.000Z",
      "dateModified": "2025-02-19T00:00:00.000Z",
      "image": "/static/images/twitter-card.png",
      "url": "https://tailwind-nextjs-starter-blog.vercel.app/krita comfyUI LCM 的实时绘画安装教程1740387002546"
    }
  },
  {
    "title": "软件工程概述",
    "date": "2025-02-01T00:00:00.000Z",
    "tags": [],
    "body": {
      "raw": "\n##  软件工程的三要素\n\n\n* 方法\n* 过程\n* 工具\n\n## **方法（Methodologies）**\n\n* 瀑布模型\n\t* 主要过程顺序进行\n* 敏捷开发\n\t* 迭代开发，快速响应。\n\t* [敏捷软件开发宣言](https://agilemanifesto.org/iso/zhchs/manifesto.html)\n* 原型模型\n\t* 快速开发一个可运行的原型，在此基础上，根据反馈进行改进。\n* 螺旋模型\n\t*  原型 + 瀑布\n\n## 软件开发的主要过程 （**Process**）\n\n过程可以分为以下阶段：\n* 需求分析阶段\n\t* 目标：确认功能，界面，性能等方面 \n\t\t* 收集方式方式：与客户直接沟通，调研，问卷\n\t* 需求分析：可行性、完整性、一致性\n\t\t* 是否可行？是否真的有其价值【伪需求？】！代价是什么【时间,资源可行】？需要做相应的技术调研【能否实现】？\n\t\t* 完整性：\n\t\t\t* 功能完整性： 涵盖的了所有的 user story.\n\t\t\t\t* 什么是user story?  【简短，非正式】\n\t\t\t\t\t* <什么人> 在 <什么地点> 干了<什么事情>, 产生了 <什么效果> 价值。\n\t\t\t\t\t* user story 的 作用：\n\t\t\t\t\t\t* 用共同的语言，促进沟通，聚焦用户需求\n\t\t\t\t\t\t*  利于排优先级与规划\n\t\t\t\t\t\t*  可以作为验收标准\n\t\t\t\t\t* 编写原则\n\t\t\t\t\t\t* 独立性: 每个用户故事需要尽量独立，不依赖其他user story。 方便并行开发。\n\t\t\t\t\t\t* 协商性: user story并不是不变的，敏捷开发中，容忍需求变动。\n\t\t\t\t\t\t* 有价值: 给产品带来收益和竞争性\n\t\t\t\t\t\t* 尽量小,可估计: 工作量和时间。一个user story 关注一个功能做到，可以测试。\n\t\t\t* 数据完整性？分析数据流，数据的输入，处理输出都有明确的需求\n\t\t\t\t* 数据字典：数据库表结构，软件的开发中的 `DTO`,`Entity`\n\t\t\t* 非功能完整性？\n\t\t\t\t* **安全，性能，兼容性**？\n\t\t\t\t* 行业标准？\n\t\t* 一致性：\n\t\t\t* 不同功能之间是否冲突？\n\t\t\t* 需求与约束条件存在冲突？\n\t* 输出：需求规格说明书\n\t\t* 描述了软件系统的功能、性能、界面、数据等方面的需求。它是开发团队和用户之间沟通的桥梁，也是后续设计、编码、测试和验收的依据。\n\t\t* 设计稿 + user story\n* 设计\n\t* 目标：总体架构，模块划分，接口设计 + 详细设计\n\t* 主要阶段\n\t\t* 概要设计：模块划分、模块之间的关系、数据结构，接口设计 ，数据流。\n\t\t* 详细设计：算法设计、数据结构设计、接口设计\n\t\t* 设计文档：系统架构图，模块设计说明书\n\t* 重要性：是开发的 “蓝图” 阶段。\n\t\t* 怎么理解？\n\t\t\t* 扩展性\n\t\t\t\t* 将功能分为多个独立【低耦合】模块，模块之间通过【接口】进行交互【数据】。\n\t\t\t\t* 系统的架构: 确定系统的**整体结构，包括系统的分层、模块划分和组件**分布\n\t\t\t\t\t* 常见的架构：分层架构，微服务架构，B/S , C/S\n\t\t\t* 维护性\n\t\t\t\t* 设计编码范式与设计模式\n\t\t\t\t* 良好的设计文档\n\t\t\t* 软件性能\n\t\t\t\t* 算法与数据结构影响\n\t\t\t\t* 服务器架构与缓存设计影响网络传输速度\n\t\t\t\t* 好的模块化设计，减少不必要的数据传输影响\n* 编码\n\t* 目的：将设计转为可以运行的代码\n\t* 流程：Code --> Unit test --> Code Review\n\t\t* 编码阶段注意：\n\t\t\t* 编码规范\n\t\t\t\t* 命名规则\n\t\t\t\t* 格式缩进\n\t\t\t* 添加注释\n\t\t\t* 代码结构\n\t\t\t\t* 面向对象的原则\n\t\t\t* 编写必要的开发文档\n\t\t\t* 持续学习，优化现有代码\n* 测试\n\t* 目的：对软件进行全面的验证，符合需求规格说明书\n\t* 流程：\n\t\t* 测试计划\n\t\t* 测试用例编写\n\t\t* 测试执行\n\t\t* 测试管理\n\t\t* 回归测试\n\t* 重要性：测试阶段是软件开发过程中的质量保障阶段，通过测试可以发现软件中的缺陷和问题，确保软件的质量。\n* 部署\n\t* 安装到目标环境\n\t* 流程：制定部署计划，步骤，以及资源\n\t* 重要性：部署可以将软件交付给用户使用\n* 维护\n\t* 定义：确保软件能够持续满足用户的需求，并适应环境的变化。\n\t* 维护阶段是软件开发过程中的持续改进阶段，通过维护可以延长软件的生命周期，提高软件的用户体验。\n\n\n```mermaid\ngraph LR\n    A[开始] --> B[需求分析]\n    B --> C{需求是否明确？}\n    C -->|是| D[设计阶段]\n    C -->|否| B\n    D --> E{设计是否符合需求？}\n    E -->|是| F[编码阶段]\n    E -->|否| B\n    F --> G[单元测试]\n    G --> H{代码是否通过测试？}\n    H -->|是| I[测试阶段]\n    H -->|否| F\n    I --> J[部署阶段]\n    J --> K[维护阶段]\n    K --> L[结束]\n```\n\n\n## 软件开发中工具（**Tools**）\n\n常见工具：\n\n* 项目管理 (jira, 看板)\n* 开发工具 \n* 版本控制 (git)\n* 测试工具 (Junit, Selenium, 性能测试工具)\n* 代码分析工具 （SonarQube）\n* 部署工具 （Docker,Kubernetes）\n### 文档工具\n\n#### 图表(**UML**)\n```\n用例图：通常在需求分析阶段使用，帮助识别系统的主要功能和参与者，为设计阶段提供基础。\n类图：在设计阶段使用，帮助设计系统的静态结构，明确类的职责和关系。\n实体关系图：在设计阶段使用，帮助设计系统的数据模型，生成数据库表结构。\n组件图：在设计阶段使用，帮助设计系统的物理结构，明确组件的职责和依赖关系。\n部署图：在设计阶段使用，帮助设计系统的物理部署结构，确保系统的正确部署。\n活动图：在需求分析和设计阶段使用，帮助理解业务流程，设计系统的业务流程。\n序列图：在设计阶段使用，帮助设计系统的动态行为，明确对象之间的交互顺序。\n状态图：在设计阶段使用，帮助设计系统的状态管理，明确对象在不同状态下的行为。\n数据流图：在需求分析和设计阶段使用，帮助理解系统的数据处理逻辑，设计数据处理流程。\n```\n\n软件工程中的图表\n├── 用例图（Use Case Diagram）\n│   ├── 定义：描述系统功能和用户交互\n│   ├── 作用\n│   │   ├── 需求分析：识别功能和参与者\n│   │   ├── 沟通工具：开发团队与用户沟通\n│   │   └── 设计基础：确定模块和接口\n│   └── 示例：在线购物系统功能\n└── 数据流图（Data Flow Diagram, DFD）\n│   ├── 定义：描述系统数据流动和处理过程\n│   ├── 作用\n│   │   ├── 需求分析：理解数据处理逻辑\n│   │   ├── 设计阶段：设计数据处理流程\n│   │   └── 文档化：提供数据处理文档\n│   └── 示例：图书馆管理系统借阅流程\n├── 类图（Class Diagram）\n│   ├── 定义：描述系统静态结构，类、接口、属性和方法\n│   ├── 作用\n│   │   ├── 设计阶段：设计类结构和关系\n│   │   ├── 代码生成：自动生成部分代码\n│   │   └── 文档化：提供类结构文档\n│   └── 示例：学生管理系统类关系\n├──，（Entity-Relationship Diagram, ERD）\n│   ├── 定义：描述系统数据模型，实体、属性和关系\n│   ├── 作用\n│   │   ├── 设计阶段：设计数据模型\n│   │   ├── 数据库设计：生成数据库表结构\n│   │   └── 文档化：提供数据模型文档\n│   └── 示例：学生管理系统数据模型\n├── 组件图（Component Diagram）\n│   ├── 定义：描述系统物理结构，组件、接口和依赖\n│   ├── 作用\n│   │   ├── 设计阶段：设计物理结构\n│   │   ├── 部署阶段：指导组件部署\n│   │   └── 文档化：提供物理结构文档\n│   └── 示例：分布式系统组件关系\n├── 部署图（Deployment Diagram）\n│   ├── 定义：描述系统物理部署结构，节点、组件和通信路径\n│   ├── 作用\n│   │   ├── 设计阶段：设计物理部署结构\n│   │   ├── 部署阶段：指导系统部署\n│   │   └── 文档化：提供物理部署文档\n│   └── 示例：云计算环境部署\n├── 活动图（Activity Diagram）\n│   ├── 定义：描述系统业务流程或工作流程\n│   ├── 作用\n│   │   ├── 需求分析：理解业务流程\n│   │   ├── 设计阶段：设计业务流程\n│   │   └── 文档化：提供业务流程文档\n│   └── 示例：请假审批系统流程\n├── 序列图（Sequence Diagram）\n│   ├── 定义：描述对象交互顺序，消息传递\n│   ├── 作用\n│   │   ├── 设计阶段：设计系统动态行为\n│   │   ├── 测试阶段：编写测试用例\n│   │   └── 文档化：提供动态行为文档\n│   └── 示例：订单处理系统交互过程\n├── 状态图（State Diagram）\n   ├── 定义：描述对象状态变化和触发事件\n   ├── 作用\n   │   ├── 设计阶段：设计状态管理\n   │   ├── 测试阶段：编写测试用例\n   │   └── 文档化：提供状态管理文档\n   └── 示例：在线支付系统状态变化\n\n\n\n",
      "html": "<h2>软件工程的三要素</h2>\n<ul>\n<li>方法</li>\n<li>过程</li>\n<li>工具</li>\n</ul>\n<h2><strong>方法（Methodologies）</strong></h2>\n<ul>\n<li>瀑布模型\n<ul>\n<li>主要过程顺序进行</li>\n</ul>\n</li>\n<li>敏捷开发\n<ul>\n<li>迭代开发，快速响应。</li>\n<li><a href=\"https://agilemanifesto.org/iso/zhchs/manifesto.html\">敏捷软件开发宣言</a></li>\n</ul>\n</li>\n<li>原型模型\n<ul>\n<li>快速开发一个可运行的原型，在此基础上，根据反馈进行改进。</li>\n</ul>\n</li>\n<li>螺旋模型\n<ul>\n<li>原型 + 瀑布</li>\n</ul>\n</li>\n</ul>\n<h2>软件开发的主要过程 （<strong>Process</strong>）</h2>\n<p>过程可以分为以下阶段：</p>\n<ul>\n<li>需求分析阶段\n<ul>\n<li>目标：确认功能，界面，性能等方面\n<ul>\n<li>收集方式方式：与客户直接沟通，调研，问卷</li>\n</ul>\n</li>\n<li>需求分析：可行性、完整性、一致性\n<ul>\n<li>是否可行？是否真的有其价值【伪需求？】！代价是什么【时间,资源可行】？需要做相应的技术调研【能否实现】？</li>\n<li>完整性：\n<ul>\n<li>功能完整性： 涵盖的了所有的 user story.\n<ul>\n<li>什么是user story?  【简短，非正式】\n<ul>\n<li>&#x3C;什么人> 在 &#x3C;什么地点> 干了&#x3C;什么事情>, 产生了 &#x3C;什么效果> 价值。</li>\n<li>user story 的 作用：\n<ul>\n<li>用共同的语言，促进沟通，聚焦用户需求</li>\n<li>利于排优先级与规划</li>\n<li>可以作为验收标准</li>\n</ul>\n</li>\n<li>编写原则\n<ul>\n<li>独立性: 每个用户故事需要尽量独立，不依赖其他user story。 方便并行开发。</li>\n<li>协商性: user story并不是不变的，敏捷开发中，容忍需求变动。</li>\n<li>有价值: 给产品带来收益和竞争性</li>\n<li>尽量小,可估计: 工作量和时间。一个user story 关注一个功能做到，可以测试。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据完整性？分析数据流，数据的输入，处理输出都有明确的需求\n<ul>\n<li>数据字典：数据库表结构，软件的开发中的 <code>DTO</code>,<code>Entity</code></li>\n</ul>\n</li>\n<li>非功能完整性？\n<ul>\n<li><strong>安全，性能，兼容性</strong>？</li>\n<li>行业标准？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>一致性：\n<ul>\n<li>不同功能之间是否冲突？</li>\n<li>需求与约束条件存在冲突？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>输出：需求规格说明书\n<ul>\n<li>描述了软件系统的功能、性能、界面、数据等方面的需求。它是开发团队和用户之间沟通的桥梁，也是后续设计、编码、测试和验收的依据。</li>\n<li>设计稿 + user story</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>设计\n<ul>\n<li>目标：总体架构，模块划分，接口设计 + 详细设计</li>\n<li>主要阶段\n<ul>\n<li>概要设计：模块划分、模块之间的关系、数据结构，接口设计 ，数据流。</li>\n<li>详细设计：算法设计、数据结构设计、接口设计</li>\n<li>设计文档：系统架构图，模块设计说明书</li>\n</ul>\n</li>\n<li>重要性：是开发的 “蓝图” 阶段。\n<ul>\n<li>怎么理解？\n<ul>\n<li>扩展性\n<ul>\n<li>将功能分为多个独立【低耦合】模块，模块之间通过【接口】进行交互【数据】。</li>\n<li>系统的架构: 确定系统的<strong>整体结构，包括系统的分层、模块划分和组件</strong>分布\n<ul>\n<li>常见的架构：分层架构，微服务架构，B/S , C/S</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>维护性\n<ul>\n<li>设计编码范式与设计模式</li>\n<li>良好的设计文档</li>\n</ul>\n</li>\n<li>软件性能\n<ul>\n<li>算法与数据结构影响</li>\n<li>服务器架构与缓存设计影响网络传输速度</li>\n<li>好的模块化设计，减少不必要的数据传输影响</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>编码\n<ul>\n<li>目的：将设计转为可以运行的代码</li>\n<li>流程：Code --> Unit test --> Code Review\n<ul>\n<li>编码阶段注意：\n<ul>\n<li>编码规范\n<ul>\n<li>命名规则</li>\n<li>格式缩进</li>\n</ul>\n</li>\n<li>添加注释</li>\n<li>代码结构\n<ul>\n<li>面向对象的原则</li>\n</ul>\n</li>\n<li>编写必要的开发文档</li>\n<li>持续学习，优化现有代码</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>测试\n<ul>\n<li>目的：对软件进行全面的验证，符合需求规格说明书</li>\n<li>流程：\n<ul>\n<li>测试计划</li>\n<li>测试用例编写</li>\n<li>测试执行</li>\n<li>测试管理</li>\n<li>回归测试</li>\n</ul>\n</li>\n<li>重要性：测试阶段是软件开发过程中的质量保障阶段，通过测试可以发现软件中的缺陷和问题，确保软件的质量。</li>\n</ul>\n</li>\n<li>部署\n<ul>\n<li>安装到目标环境</li>\n<li>流程：制定部署计划，步骤，以及资源</li>\n<li>重要性：部署可以将软件交付给用户使用</li>\n</ul>\n</li>\n<li>维护\n<ul>\n<li>定义：确保软件能够持续满足用户的需求，并适应环境的变化。</li>\n<li>维护阶段是软件开发过程中的持续改进阶段，通过维护可以延长软件的生命周期，提高软件的用户体验。</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-mermaid\">graph LR\n    A[开始] --> B[需求分析]\n    B --> C{需求是否明确？}\n    C -->|是| D[设计阶段]\n    C -->|否| B\n    D --> E{设计是否符合需求？}\n    E -->|是| F[编码阶段]\n    E -->|否| B\n    F --> G[单元测试]\n    G --> H{代码是否通过测试？}\n    H -->|是| I[测试阶段]\n    H -->|否| F\n    I --> J[部署阶段]\n    J --> K[维护阶段]\n    K --> L[结束]\n</code></pre>\n<h2>软件开发中工具（<strong>Tools</strong>）</h2>\n<p>常见工具：</p>\n<ul>\n<li>项目管理 (jira, 看板)</li>\n<li>开发工具</li>\n<li>版本控制 (git)</li>\n<li>测试工具 (Junit, Selenium, 性能测试工具)</li>\n<li>代码分析工具 （SonarQube）</li>\n<li>部署工具 （Docker,Kubernetes）</li>\n</ul>\n<h3>文档工具</h3>\n<h4>图表(<strong>UML</strong>)</h4>\n<pre><code>用例图：通常在需求分析阶段使用，帮助识别系统的主要功能和参与者，为设计阶段提供基础。\n类图：在设计阶段使用，帮助设计系统的静态结构，明确类的职责和关系。\n实体关系图：在设计阶段使用，帮助设计系统的数据模型，生成数据库表结构。\n组件图：在设计阶段使用，帮助设计系统的物理结构，明确组件的职责和依赖关系。\n部署图：在设计阶段使用，帮助设计系统的物理部署结构，确保系统的正确部署。\n活动图：在需求分析和设计阶段使用，帮助理解业务流程，设计系统的业务流程。\n序列图：在设计阶段使用，帮助设计系统的动态行为，明确对象之间的交互顺序。\n状态图：在设计阶段使用，帮助设计系统的状态管理，明确对象在不同状态下的行为。\n数据流图：在需求分析和设计阶段使用，帮助理解系统的数据处理逻辑，设计数据处理流程。\n</code></pre>\n<p>软件工程中的图表\n├── 用例图（Use Case Diagram）\n│   ├── 定义：描述系统功能和用户交互\n│   ├── 作用\n│   │   ├── 需求分析：识别功能和参与者\n│   │   ├── 沟通工具：开发团队与用户沟通\n│   │   └── 设计基础：确定模块和接口\n│   └── 示例：在线购物系统功能\n└── 数据流图（Data Flow Diagram, DFD）\n│   ├── 定义：描述系统数据流动和处理过程\n│   ├── 作用\n│   │   ├── 需求分析：理解数据处理逻辑\n│   │   ├── 设计阶段：设计数据处理流程\n│   │   └── 文档化：提供数据处理文档\n│   └── 示例：图书馆管理系统借阅流程\n├── 类图（Class Diagram）\n│   ├── 定义：描述系统静态结构，类、接口、属性和方法\n│   ├── 作用\n│   │   ├── 设计阶段：设计类结构和关系\n│   │   ├── 代码生成：自动生成部分代码\n│   │   └── 文档化：提供类结构文档\n│   └── 示例：学生管理系统类关系\n├──，（Entity-Relationship Diagram, ERD）\n│   ├── 定义：描述系统数据模型，实体、属性和关系\n│   ├── 作用\n│   │   ├── 设计阶段：设计数据模型\n│   │   ├── 数据库设计：生成数据库表结构\n│   │   └── 文档化：提供数据模型文档\n│   └── 示例：学生管理系统数据模型\n├── 组件图（Component Diagram）\n│   ├── 定义：描述系统物理结构，组件、接口和依赖\n│   ├── 作用\n│   │   ├── 设计阶段：设计物理结构\n│   │   ├── 部署阶段：指导组件部署\n│   │   └── 文档化：提供物理结构文档\n│   └── 示例：分布式系统组件关系\n├── 部署图（Deployment Diagram）\n│   ├── 定义：描述系统物理部署结构，节点、组件和通信路径\n│   ├── 作用\n│   │   ├── 设计阶段：设计物理部署结构\n│   │   ├── 部署阶段：指导系统部署\n│   │   └── 文档化：提供物理部署文档\n│   └── 示例：云计算环境部署\n├── 活动图（Activity Diagram）\n│   ├── 定义：描述系统业务流程或工作流程\n│   ├── 作用\n│   │   ├── 需求分析：理解业务流程\n│   │   ├── 设计阶段：设计业务流程\n│   │   └── 文档化：提供业务流程文档\n│   └── 示例：请假审批系统流程\n├── 序列图（Sequence Diagram）\n│   ├── 定义：描述对象交互顺序，消息传递\n│   ├── 作用\n│   │   ├── 设计阶段：设计系统动态行为\n│   │   ├── 测试阶段：编写测试用例\n│   │   └── 文档化：提供动态行为文档\n│   └── 示例：订单处理系统交互过程\n├── 状态图（State Diagram）\n├── 定义：描述对象状态变化和触发事件\n├── 作用\n│   ├── 设计阶段：设计状态管理\n│   ├── 测试阶段：编写测试用例\n│   └── 文档化：提供状态管理文档\n└── 示例：在线支付系统状态变化</p>"
    },
    "_id": "软件工程概述.md",
    "_raw": {
      "sourceFilePath": "软件工程概述.md",
      "sourceFileName": "软件工程概述.md",
      "sourceFileDir": ".",
      "contentType": "markdown",
      "flattenedPath": "软件工程概述"
    },
    "type": "Post",
    "slug": "软件工程概述",
    "path": "软件工程概述",
    "filePath": "软件工程概述.md",
    "toc": [
      {
        "value": "软件工程的三要素",
        "url": "#软件工程的三要素",
        "depth": 2
      },
      {
        "value": "方法（Methodologies）",
        "url": "#方法methodologies",
        "depth": 2
      },
      {
        "value": "软件开发的主要过程 （Process）",
        "url": "#软件开发的主要过程-process",
        "depth": 2
      },
      {
        "value": "软件开发中工具（Tools）",
        "url": "#软件开发中工具tools",
        "depth": 2
      },
      {
        "value": "文档工具",
        "url": "#文档工具",
        "depth": 3
      },
      {
        "value": "图表(UML)",
        "url": "#图表uml",
        "depth": 4
      }
    ],
    "structuredData": {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "headline": "软件工程概述",
      "datePublished": "2025-02-01T00:00:00.000Z",
      "dateModified": "2025-02-01T00:00:00.000Z",
      "image": "/static/images/twitter-card.png",
      "url": "https://tailwind-nextjs-starter-blog.vercel.app/软件工程概述"
    }
  },
  {
    "title": "软件工程概述",
    "date": "2025-02-01T00:00:00.000Z",
    "tags": [],
    "body": {
      "raw": "\n##  软件工程的三要素\n\n\n* 方法\n* 过程\n* 工具\n\n## **方法（Methodologies）**\n\n* 瀑布模型\n\t* 主要过程顺序进行\n* 敏捷开发\n\t* 迭代开发，快速响应。\n\t* [敏捷软件开发宣言](https://agilemanifesto.org/iso/zhchs/manifesto.html)\n* 原型模型\n\t* 快速开发一个可运行的原型，在此基础上，根据反馈进行改进。\n* 螺旋模型\n\t*  原型 + 瀑布\n\n## 软件开发的主要过程 （**Process**）\n\n过程可以分为以下阶段：\n* 需求分析阶段\n\t* 目标：确认功能，界面，性能等方面 \n\t\t* 收集方式方式：与客户直接沟通，调研，问卷\n\t* 需求分析：可行性、完整性、一致性\n\t\t* 是否可行？是否真的有其价值【伪需求？】！代价是什么【时间,资源可行】？需要做相应的技术调研【能否实现】？\n\t\t* 完整性：\n\t\t\t* 功能完整性： 涵盖的了所有的 user story.\n\t\t\t\t* 什么是user story?  【简短，非正式】\n\t\t\t\t\t* <什么人> 在 <什么地点> 干了<什么事情>, 产生了 <什么效果> 价值。\n\t\t\t\t\t* user story 的 作用：\n\t\t\t\t\t\t* 用共同的语言，促进沟通，聚焦用户需求\n\t\t\t\t\t\t*  利于排优先级与规划\n\t\t\t\t\t\t*  可以作为验收标准\n\t\t\t\t\t* 编写原则\n\t\t\t\t\t\t* 独立性: 每个用户故事需要尽量独立，不依赖其他user story。 方便并行开发。\n\t\t\t\t\t\t* 协商性: user story并不是不变的，敏捷开发中，容忍需求变动。\n\t\t\t\t\t\t* 有价值: 给产品带来收益和竞争性\n\t\t\t\t\t\t* 尽量小,可估计: 工作量和时间。一个user story 关注一个功能做到，可以测试。\n\t\t\t* 数据完整性？分析数据流，数据的输入，处理输出都有明确的需求\n\t\t\t\t* 数据字典：数据库表结构，软件的开发中的 `DTO`,`Entity`\n\t\t\t* 非功能完整性？\n\t\t\t\t* **安全，性能，兼容性**？\n\t\t\t\t* 行业标准？\n\t\t* 一致性：\n\t\t\t* 不同功能之间是否冲突？\n\t\t\t* 需求与约束条件存在冲突？\n\t* 输出：需求规格说明书\n\t\t* 描述了软件系统的功能、性能、界面、数据等方面的需求。它是开发团队和用户之间沟通的桥梁，也是后续设计、编码、测试和验收的依据。\n\t\t* 设计稿 + user story\n* 设计\n\t* 目标：总体架构，模块划分，接口设计 + 详细设计\n\t* 主要阶段\n\t\t* 概要设计：模块划分、模块之间的关系、数据结构，接口设计 ，数据流。\n\t\t* 详细设计：算法设计、数据结构设计、接口设计\n\t\t* 设计文档：系统架构图，模块设计说明书\n\t* 重要性：是开发的 “蓝图” 阶段。\n\t\t* 怎么理解？\n\t\t\t* 扩展性\n\t\t\t\t* 将功能分为多个独立【低耦合】模块，模块之间通过【接口】进行交互【数据】。\n\t\t\t\t* 系统的架构: 确定系统的**整体结构，包括系统的分层、模块划分和组件**分布\n\t\t\t\t\t* 常见的架构：分层架构，微服务架构，B/S , C/S\n\t\t\t* 维护性\n\t\t\t\t* 设计编码范式与设计模式\n\t\t\t\t* 良好的设计文档\n\t\t\t* 软件性能\n\t\t\t\t* 算法与数据结构影响\n\t\t\t\t* 服务器架构与缓存设计影响网络传输速度\n\t\t\t\t* 好的模块化设计，减少不必要的数据传输影响\n* 编码\n\t* 目的：将设计转为可以运行的代码\n\t* 流程：Code --> Unit test --> Code Review\n\t\t* 编码阶段注意：\n\t\t\t* 编码规范\n\t\t\t\t* 命名规则\n\t\t\t\t* 格式缩进\n\t\t\t* 添加注释\n\t\t\t* 代码结构\n\t\t\t\t* 面向对象的原则\n\t\t\t* 编写必要的开发文档\n\t\t\t* 持续学习，优化现有代码\n* 测试\n\t* 目的：对软件进行全面的验证，符合需求规格说明书\n\t* 流程：\n\t\t* 测试计划\n\t\t* 测试用例编写\n\t\t* 测试执行\n\t\t* 测试管理\n\t\t* 回归测试\n\t* 重要性：测试阶段是软件开发过程中的质量保障阶段，通过测试可以发现软件中的缺陷和问题，确保软件的质量。\n* 部署\n\t* 安装到目标环境\n\t* 流程：制定部署计划，步骤，以及资源\n\t* 重要性：部署可以将软件交付给用户使用\n* 维护\n\t* 定义：确保软件能够持续满足用户的需求，并适应环境的变化。\n\t* 维护阶段是软件开发过程中的持续改进阶段，通过维护可以延长软件的生命周期，提高软件的用户体验。\n\n\n```mermaid\ngraph LR\n    A[开始] --> B[需求分析]\n    B --> C{需求是否明确？}\n    C -->|是| D[设计阶段]\n    C -->|否| B\n    D --> E{设计是否符合需求？}\n    E -->|是| F[编码阶段]\n    E -->|否| B\n    F --> G[单元测试]\n    G --> H{代码是否通过测试？}\n    H -->|是| I[测试阶段]\n    H -->|否| F\n    I --> J[部署阶段]\n    J --> K[维护阶段]\n    K --> L[结束]\n```\n\n\n## 软件开发中工具（**Tools**）\n\n常见工具：\n\n* 项目管理 (jira, 看板)\n* 开发工具 \n* 版本控制 (git)\n* 测试工具 (Junit, Selenium, 性能测试工具)\n* 代码分析工具 （SonarQube）\n* 部署工具 （Docker,Kubernetes）\n### 文档工具\n\n#### 图表(**UML**)\n```\n用例图：通常在需求分析阶段使用，帮助识别系统的主要功能和参与者，为设计阶段提供基础。\n类图：在设计阶段使用，帮助设计系统的静态结构，明确类的职责和关系。\n实体关系图：在设计阶段使用，帮助设计系统的数据模型，生成数据库表结构。\n组件图：在设计阶段使用，帮助设计系统的物理结构，明确组件的职责和依赖关系。\n部署图：在设计阶段使用，帮助设计系统的物理部署结构，确保系统的正确部署。\n活动图：在需求分析和设计阶段使用，帮助理解业务流程，设计系统的业务流程。\n序列图：在设计阶段使用，帮助设计系统的动态行为，明确对象之间的交互顺序。\n状态图：在设计阶段使用，帮助设计系统的状态管理，明确对象在不同状态下的行为。\n数据流图：在需求分析和设计阶段使用，帮助理解系统的数据处理逻辑，设计数据处理流程。\n```\n\n软件工程中的图表\n├── 用例图（Use Case Diagram）\n│   ├── 定义：描述系统功能和用户交互\n│   ├── 作用\n│   │   ├── 需求分析：识别功能和参与者\n│   │   ├── 沟通工具：开发团队与用户沟通\n│   │   └── 设计基础：确定模块和接口\n│   └── 示例：在线购物系统功能\n└── 数据流图（Data Flow Diagram, DFD）\n│   ├── 定义：描述系统数据流动和处理过程\n│   ├── 作用\n│   │   ├── 需求分析：理解数据处理逻辑\n│   │   ├── 设计阶段：设计数据处理流程\n│   │   └── 文档化：提供数据处理文档\n│   └── 示例：图书馆管理系统借阅流程\n├── 类图（Class Diagram）\n│   ├── 定义：描述系统静态结构，类、接口、属性和方法\n│   ├── 作用\n│   │   ├── 设计阶段：设计类结构和关系\n│   │   ├── 代码生成：自动生成部分代码\n│   │   └── 文档化：提供类结构文档\n│   └── 示例：学生管理系统类关系\n├──，（Entity-Relationship Diagram, ERD）\n│   ├── 定义：描述系统数据模型，实体、属性和关系\n│   ├── 作用\n│   │   ├── 设计阶段：设计数据模型\n│   │   ├── 数据库设计：生成数据库表结构\n│   │   └── 文档化：提供数据模型文档\n│   └── 示例：学生管理系统数据模型\n├── 组件图（Component Diagram）\n│   ├── 定义：描述系统物理结构，组件、接口和依赖\n│   ├── 作用\n│   │   ├── 设计阶段：设计物理结构\n│   │   ├── 部署阶段：指导组件部署\n│   │   └── 文档化：提供物理结构文档\n│   └── 示例：分布式系统组件关系\n├── 部署图（Deployment Diagram）\n│   ├── 定义：描述系统物理部署结构，节点、组件和通信路径\n│   ├── 作用\n│   │   ├── 设计阶段：设计物理部署结构\n│   │   ├── 部署阶段：指导系统部署\n│   │   └── 文档化：提供物理部署文档\n│   └── 示例：云计算环境部署\n├── 活动图（Activity Diagram）\n│   ├── 定义：描述系统业务流程或工作流程\n│   ├── 作用\n│   │   ├── 需求分析：理解业务流程\n│   │   ├── 设计阶段：设计业务流程\n│   │   └── 文档化：提供业务流程文档\n│   └── 示例：请假审批系统流程\n├── 序列图（Sequence Diagram）\n│   ├── 定义：描述对象交互顺序，消息传递\n│   ├── 作用\n│   │   ├── 设计阶段：设计系统动态行为\n│   │   ├── 测试阶段：编写测试用例\n│   │   └── 文档化：提供动态行为文档\n│   └── 示例：订单处理系统交互过程\n├── 状态图（State Diagram）\n   ├── 定义：描述对象状态变化和触发事件\n   ├── 作用\n   │   ├── 设计阶段：设计状态管理\n   │   ├── 测试阶段：编写测试用例\n   │   └── 文档化：提供状态管理文档\n   └── 示例：在线支付系统状态变化\n\n\n\n",
      "html": "<h2>软件工程的三要素</h2>\n<ul>\n<li>方法</li>\n<li>过程</li>\n<li>工具</li>\n</ul>\n<h2><strong>方法（Methodologies）</strong></h2>\n<ul>\n<li>瀑布模型\n<ul>\n<li>主要过程顺序进行</li>\n</ul>\n</li>\n<li>敏捷开发\n<ul>\n<li>迭代开发，快速响应。</li>\n<li><a href=\"https://agilemanifesto.org/iso/zhchs/manifesto.html\">敏捷软件开发宣言</a></li>\n</ul>\n</li>\n<li>原型模型\n<ul>\n<li>快速开发一个可运行的原型，在此基础上，根据反馈进行改进。</li>\n</ul>\n</li>\n<li>螺旋模型\n<ul>\n<li>原型 + 瀑布</li>\n</ul>\n</li>\n</ul>\n<h2>软件开发的主要过程 （<strong>Process</strong>）</h2>\n<p>过程可以分为以下阶段：</p>\n<ul>\n<li>需求分析阶段\n<ul>\n<li>目标：确认功能，界面，性能等方面\n<ul>\n<li>收集方式方式：与客户直接沟通，调研，问卷</li>\n</ul>\n</li>\n<li>需求分析：可行性、完整性、一致性\n<ul>\n<li>是否可行？是否真的有其价值【伪需求？】！代价是什么【时间,资源可行】？需要做相应的技术调研【能否实现】？</li>\n<li>完整性：\n<ul>\n<li>功能完整性： 涵盖的了所有的 user story.\n<ul>\n<li>什么是user story?  【简短，非正式】\n<ul>\n<li>&#x3C;什么人> 在 &#x3C;什么地点> 干了&#x3C;什么事情>, 产生了 &#x3C;什么效果> 价值。</li>\n<li>user story 的 作用：\n<ul>\n<li>用共同的语言，促进沟通，聚焦用户需求</li>\n<li>利于排优先级与规划</li>\n<li>可以作为验收标准</li>\n</ul>\n</li>\n<li>编写原则\n<ul>\n<li>独立性: 每个用户故事需要尽量独立，不依赖其他user story。 方便并行开发。</li>\n<li>协商性: user story并不是不变的，敏捷开发中，容忍需求变动。</li>\n<li>有价值: 给产品带来收益和竞争性</li>\n<li>尽量小,可估计: 工作量和时间。一个user story 关注一个功能做到，可以测试。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据完整性？分析数据流，数据的输入，处理输出都有明确的需求\n<ul>\n<li>数据字典：数据库表结构，软件的开发中的 <code>DTO</code>,<code>Entity</code></li>\n</ul>\n</li>\n<li>非功能完整性？\n<ul>\n<li><strong>安全，性能，兼容性</strong>？</li>\n<li>行业标准？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>一致性：\n<ul>\n<li>不同功能之间是否冲突？</li>\n<li>需求与约束条件存在冲突？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>输出：需求规格说明书\n<ul>\n<li>描述了软件系统的功能、性能、界面、数据等方面的需求。它是开发团队和用户之间沟通的桥梁，也是后续设计、编码、测试和验收的依据。</li>\n<li>设计稿 + user story</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>设计\n<ul>\n<li>目标：总体架构，模块划分，接口设计 + 详细设计</li>\n<li>主要阶段\n<ul>\n<li>概要设计：模块划分、模块之间的关系、数据结构，接口设计 ，数据流。</li>\n<li>详细设计：算法设计、数据结构设计、接口设计</li>\n<li>设计文档：系统架构图，模块设计说明书</li>\n</ul>\n</li>\n<li>重要性：是开发的 “蓝图” 阶段。\n<ul>\n<li>怎么理解？\n<ul>\n<li>扩展性\n<ul>\n<li>将功能分为多个独立【低耦合】模块，模块之间通过【接口】进行交互【数据】。</li>\n<li>系统的架构: 确定系统的<strong>整体结构，包括系统的分层、模块划分和组件</strong>分布\n<ul>\n<li>常见的架构：分层架构，微服务架构，B/S , C/S</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>维护性\n<ul>\n<li>设计编码范式与设计模式</li>\n<li>良好的设计文档</li>\n</ul>\n</li>\n<li>软件性能\n<ul>\n<li>算法与数据结构影响</li>\n<li>服务器架构与缓存设计影响网络传输速度</li>\n<li>好的模块化设计，减少不必要的数据传输影响</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>编码\n<ul>\n<li>目的：将设计转为可以运行的代码</li>\n<li>流程：Code --> Unit test --> Code Review\n<ul>\n<li>编码阶段注意：\n<ul>\n<li>编码规范\n<ul>\n<li>命名规则</li>\n<li>格式缩进</li>\n</ul>\n</li>\n<li>添加注释</li>\n<li>代码结构\n<ul>\n<li>面向对象的原则</li>\n</ul>\n</li>\n<li>编写必要的开发文档</li>\n<li>持续学习，优化现有代码</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>测试\n<ul>\n<li>目的：对软件进行全面的验证，符合需求规格说明书</li>\n<li>流程：\n<ul>\n<li>测试计划</li>\n<li>测试用例编写</li>\n<li>测试执行</li>\n<li>测试管理</li>\n<li>回归测试</li>\n</ul>\n</li>\n<li>重要性：测试阶段是软件开发过程中的质量保障阶段，通过测试可以发现软件中的缺陷和问题，确保软件的质量。</li>\n</ul>\n</li>\n<li>部署\n<ul>\n<li>安装到目标环境</li>\n<li>流程：制定部署计划，步骤，以及资源</li>\n<li>重要性：部署可以将软件交付给用户使用</li>\n</ul>\n</li>\n<li>维护\n<ul>\n<li>定义：确保软件能够持续满足用户的需求，并适应环境的变化。</li>\n<li>维护阶段是软件开发过程中的持续改进阶段，通过维护可以延长软件的生命周期，提高软件的用户体验。</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-mermaid\">graph LR\n    A[开始] --> B[需求分析]\n    B --> C{需求是否明确？}\n    C -->|是| D[设计阶段]\n    C -->|否| B\n    D --> E{设计是否符合需求？}\n    E -->|是| F[编码阶段]\n    E -->|否| B\n    F --> G[单元测试]\n    G --> H{代码是否通过测试？}\n    H -->|是| I[测试阶段]\n    H -->|否| F\n    I --> J[部署阶段]\n    J --> K[维护阶段]\n    K --> L[结束]\n</code></pre>\n<h2>软件开发中工具（<strong>Tools</strong>）</h2>\n<p>常见工具：</p>\n<ul>\n<li>项目管理 (jira, 看板)</li>\n<li>开发工具</li>\n<li>版本控制 (git)</li>\n<li>测试工具 (Junit, Selenium, 性能测试工具)</li>\n<li>代码分析工具 （SonarQube）</li>\n<li>部署工具 （Docker,Kubernetes）</li>\n</ul>\n<h3>文档工具</h3>\n<h4>图表(<strong>UML</strong>)</h4>\n<pre><code>用例图：通常在需求分析阶段使用，帮助识别系统的主要功能和参与者，为设计阶段提供基础。\n类图：在设计阶段使用，帮助设计系统的静态结构，明确类的职责和关系。\n实体关系图：在设计阶段使用，帮助设计系统的数据模型，生成数据库表结构。\n组件图：在设计阶段使用，帮助设计系统的物理结构，明确组件的职责和依赖关系。\n部署图：在设计阶段使用，帮助设计系统的物理部署结构，确保系统的正确部署。\n活动图：在需求分析和设计阶段使用，帮助理解业务流程，设计系统的业务流程。\n序列图：在设计阶段使用，帮助设计系统的动态行为，明确对象之间的交互顺序。\n状态图：在设计阶段使用，帮助设计系统的状态管理，明确对象在不同状态下的行为。\n数据流图：在需求分析和设计阶段使用，帮助理解系统的数据处理逻辑，设计数据处理流程。\n</code></pre>\n<p>软件工程中的图表\n├── 用例图（Use Case Diagram）\n│   ├── 定义：描述系统功能和用户交互\n│   ├── 作用\n│   │   ├── 需求分析：识别功能和参与者\n│   │   ├── 沟通工具：开发团队与用户沟通\n│   │   └── 设计基础：确定模块和接口\n│   └── 示例：在线购物系统功能\n└── 数据流图（Data Flow Diagram, DFD）\n│   ├── 定义：描述系统数据流动和处理过程\n│   ├── 作用\n│   │   ├── 需求分析：理解数据处理逻辑\n│   │   ├── 设计阶段：设计数据处理流程\n│   │   └── 文档化：提供数据处理文档\n│   └── 示例：图书馆管理系统借阅流程\n├── 类图（Class Diagram）\n│   ├── 定义：描述系统静态结构，类、接口、属性和方法\n│   ├── 作用\n│   │   ├── 设计阶段：设计类结构和关系\n│   │   ├── 代码生成：自动生成部分代码\n│   │   └── 文档化：提供类结构文档\n│   └── 示例：学生管理系统类关系\n├──，（Entity-Relationship Diagram, ERD）\n│   ├── 定义：描述系统数据模型，实体、属性和关系\n│   ├── 作用\n│   │   ├── 设计阶段：设计数据模型\n│   │   ├── 数据库设计：生成数据库表结构\n│   │   └── 文档化：提供数据模型文档\n│   └── 示例：学生管理系统数据模型\n├── 组件图（Component Diagram）\n│   ├── 定义：描述系统物理结构，组件、接口和依赖\n│   ├── 作用\n│   │   ├── 设计阶段：设计物理结构\n│   │   ├── 部署阶段：指导组件部署\n│   │   └── 文档化：提供物理结构文档\n│   └── 示例：分布式系统组件关系\n├── 部署图（Deployment Diagram）\n│   ├── 定义：描述系统物理部署结构，节点、组件和通信路径\n│   ├── 作用\n│   │   ├── 设计阶段：设计物理部署结构\n│   │   ├── 部署阶段：指导系统部署\n│   │   └── 文档化：提供物理部署文档\n│   └── 示例：云计算环境部署\n├── 活动图（Activity Diagram）\n│   ├── 定义：描述系统业务流程或工作流程\n│   ├── 作用\n│   │   ├── 需求分析：理解业务流程\n│   │   ├── 设计阶段：设计业务流程\n│   │   └── 文档化：提供业务流程文档\n│   └── 示例：请假审批系统流程\n├── 序列图（Sequence Diagram）\n│   ├── 定义：描述对象交互顺序，消息传递\n│   ├── 作用\n│   │   ├── 设计阶段：设计系统动态行为\n│   │   ├── 测试阶段：编写测试用例\n│   │   └── 文档化：提供动态行为文档\n│   └── 示例：订单处理系统交互过程\n├── 状态图（State Diagram）\n├── 定义：描述对象状态变化和触发事件\n├── 作用\n│   ├── 设计阶段：设计状态管理\n│   ├── 测试阶段：编写测试用例\n│   └── 文档化：提供状态管理文档\n└── 示例：在线支付系统状态变化</p>"
    },
    "_id": "软件工程概述1740387301863.md",
    "_raw": {
      "sourceFilePath": "软件工程概述1740387301863.md",
      "sourceFileName": "软件工程概述1740387301863.md",
      "sourceFileDir": ".",
      "contentType": "markdown",
      "flattenedPath": "软件工程概述1740387301863"
    },
    "type": "Post",
    "slug": "软件工程概述1740387301863",
    "path": "软件工程概述1740387301863",
    "filePath": "软件工程概述1740387301863.md",
    "toc": [
      {
        "value": "软件工程的三要素",
        "url": "#软件工程的三要素",
        "depth": 2
      },
      {
        "value": "方法（Methodologies）",
        "url": "#方法methodologies",
        "depth": 2
      },
      {
        "value": "软件开发的主要过程 （Process）",
        "url": "#软件开发的主要过程-process",
        "depth": 2
      },
      {
        "value": "软件开发中工具（Tools）",
        "url": "#软件开发中工具tools",
        "depth": 2
      },
      {
        "value": "文档工具",
        "url": "#文档工具",
        "depth": 3
      },
      {
        "value": "图表(UML)",
        "url": "#图表uml",
        "depth": 4
      }
    ],
    "structuredData": {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "headline": "软件工程概述",
      "datePublished": "2025-02-01T00:00:00.000Z",
      "dateModified": "2025-02-01T00:00:00.000Z",
      "image": "/static/images/twitter-card.png",
      "url": "https://tailwind-nextjs-starter-blog.vercel.app/软件工程概述1740387301863"
    }
  }
]